////////////////////////////////////////////////////////////////////////
//
// This file is part of Common Text Transformation Library.
// Copyright (C) 1997-2009 by Igor Kholodov. 
//
// Common Text Transformation Library is free software: you can
// redistribute it and/or modify it under the terms of the
// GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Common Text Transformation Library is distributed in the hope
// that it will be useful, but WITHOUT ANY WARRANTY; without even
// the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
// PURPOSE.  See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with Common Text Transformation Library.
// If not, see <http://www.gnu.org/licenses/>.
//
// mailto:cttl@users.sourceforge.net
// http://cttl.sourceforge.net/
// http://sourceforge.net/projects/cttl/
//
////////////////////////////////////////////////////////////////////////

// sample code: balanced_output.cpp
//
// Output generated by GCC compiler while reporting error and warning
// messages can be difficult to read. This program formats the output of
// GCC compiler.
//
// The program loads input file, specified as a command line parameter,
// inserts white space indentation of square brackets, angle brackets,
// parenthesis, and quoted literals, and displays the result on the
// standard output device.

//#define NDEBUG    // define before assert.h to stop assertions from being compiled 
//#define CTTL_TRACE_EVERYTHING

#include <iostream>
#include "cttl/cttl.h"
#include "lambda/lambda.h"
#include "utils/itos.h"
#include "utils/fileio.h"

using namespace cttl;

struct balanced_output {
    int current_level;

    balanced_output()
        :
        current_level( 0 )
    {
    }

    size_t grammar( edge<>& edge_ )
    {
        return (
            *(
                !!(
                    // catch various balanced pairs
                    begin( "\"([<`" )
                    +
                    *(
                        // insert new line before opening symbol
                        scalar( &edge_.first ) += scalar( std::string( "\n" ) )
                        ,
                        scalar( &edge_.first )
                        +=
                        ++(
                            scalar( std::string() )
                            ^
                            CTTL_MEMBER_ACTION_NOARG(
                                this,
                                std::mem_fun( &balanced_output::justify_level )
                            )
                        )
                        ,
                        ++scalar( &current_level )
                    )
                    +
                    (
                        (
                            quote(
                                symbol( '(' ),
                                CTTL_RULE( balanced_output::grammar ),
                                symbol( ')' ) || symbol( '\n' )
                            )
                        )
                        |
                        (
                            quote(
                                symbol( '[' ),
                                CTTL_RULE( balanced_output::grammar ),
                                symbol( ']' ) || symbol( '\n' )
                            )
                        )
                        |
                        (
                            quote(
                                symbol( '<' ),
                                CTTL_RULE( balanced_output::grammar ),
                                symbol( '>' ) || symbol( '\n' )
                            )
                        )
                        |
                        (
                            quote(
                                symbol( '`' ),
                                CTTL_RULE( balanced_output::grammar ),
                                symbol( '\'' ) || symbol( '\n' )
                            )
                        )
                        |
                        (
                            c_double_quote(
                                CTTL_RULE( balanced_output::grammar )
                            )
                        )
                    )
                    +
                    *(
                        // insert new line after closing symbol
                        --scalar( &current_level )
                        ,
                        scalar( &edge_.first ) += scalar( std::string( "\n" ) )
                        ,
                        scalar( &edge_.first )
                        +=
                        ++(
                            scalar( std::string() )
                            ^
                            CTTL_MEMBER_ACTION_NOARG(
                                this,
                                std::mem_fun( &balanced_output::justify_level )
                            )
                        )
                    )
                )
            )

        ).match( edge_ );
    }

    std::string justify_level()
    {
        if ( current_level <= 0 )
            return "";

        return std::string( current_level, ' ' );
    }

};

int main(int argc, char* argv[])
{
    if ( argc == 1 ) {
        std::cout
            << "usage: specify input text file containing GCC error messages to format."
            << std::endl
            ;
        return 1;
    }

    std::string inp;
    file2string( argv[ 1 ], inp );
    if( !inp.length() ) {
        std::cout
            << "*** Error message from " << argv[ 0 ]
            << "\n*** Input file [" << argv[ 1 ] << "] is empty."
            ;
    }
    edge<> substring( inp );

    balanced_output parser;
    if ( parser.grammar( substring ) != std::string::npos ) {
        std::cout << inp;
        return 0;
    }

    std::cout << "*** parser failed ***" << std::endl;
    return 1;
}
