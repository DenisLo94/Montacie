////////////////////////////////////////////////////////////////////////
//
// This file is part of Common Text Transformation Library.
// Copyright (C) 1997-2009 by Igor Kholodov. 
//
// Common Text Transformation Library is free software: you can
// redistribute it and/or modify it under the terms of the
// GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Common Text Transformation Library is distributed in the hope
// that it will be useful, but WITHOUT ANY WARRANTY; without even
// the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
// PURPOSE.  See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with Common Text Transformation Library.
// If not, see <http://www.gnu.org/licenses/>.
//
// mailto:cttl@users.sourceforge.net
// http://cttl.sourceforge.net/
// http://sourceforge.net/projects/cttl/
//
////////////////////////////////////////////////////////////////////////

/**@file xst_assignment_adaptors.h
 * @brief Defines lambda assignment operator policy classes.
 *
 * This file was generated by gumus script on Sun Aug 16 21:52:47 2009.
 *
 * @warning
 *      This is internal CTTL header file and should not
 *      be included by user programs.
 *
 */

// xst_assignment_adaptors.h

#ifndef _XST_ASSIGNMENT_ADAPTORS_H_INCLUDED_
#define _XST_ASSIGNMENT_ADAPTORS_H_INCLUDED_

namespace cttl_impl {

// generated by bin/gmu/gmu_lambda/gmu_common.h:784
// generated by bin/gmu/gmu_lambda/gmu_common.h:98
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:1
/**Primary template for cttt_impl::xst_assignment_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_assignment_policy {
};//xst_assignment_policy

// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:7

// X=R -> A<R_=1,X_=1,iscalar>, where A := xst_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_assignment_policy< 1, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X=R</tt>.
 *
 @code
    X=R
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template<>
struct xst_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_assignment;

    /**Implementation of assignment assignment operator for
    *  lambda expression <tt>X=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( = " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) = rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X=R</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X=R</tt> succeeds if integral result of lambda
    *    expression <tt>X=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:101
// generated by bin\gmu\gmu_lambda\operators/assign/multi_assignment_adaptor_struct.h:1

// X=M -> A<M_,X_=1,id>, where A := xst_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_assignment_policy< RhsCapacityT, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X=M</tt>.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 @code
    X=M
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template< int RhsCapacityT >//, int PrimitiveIdT > 
struct xst_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_assignment;

    /**Implementation of assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( = " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) = rhs_lambda_;
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X=M</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X=M</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X=M</tt> succeeds if integral result of lambda
    *    expression <tt>X=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:104
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_unary_adaptors.h:1

// U=R -> A<R_,U_,iunary>, where A := xst_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >

/**@struct xst_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >
 * @brief policy specialization for binary <tt>U=R</tt> lambda expressions.
 *
 @code
    U=R
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the
 *        left-hand-side unary operator policy.
 *
 */
template< int RhsCapacityT, int LhsCapacityT >
struct xst_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_assignment;

    /**Implementation of assignment assignment operator for
    *  lambda expression <tt>U=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( = " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->prefix_side_effects();
        typename LambdaLhsT::value_T lhs_value = ( const_cast< LambdaLhsT* >( &lhs_lambda_ )->lvalue_ref() = rhs_lambda_.top( const_scalar( 0 ) ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return lhs_value;
    }

    /**Lvalue support: result of assignment to U is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * The implementation is similar to <tt>top()</tt> but excludes left-hand-side
    * postfix side effects does not return any value.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( = " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        lhs_lambda_.prefix_side_effects();
        lhs_lambda_.lvalue_ref() = rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& lhs_lambda_ )
    {
        lhs_lambda_.postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U=R</tt> succeeds if integral result of lambda
    *    expression <tt>U=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:788
// generated by bin/gmu/gmu_lambda/gmu_common.h:124
// generated by bin\gmu\gmu_lambda\operators/assign/stackpush_assignment_adaptor.h:1

// S=R -> A<R_=1,S_=1,istack>, where A := xst_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_stack >

/**@struct xst_assignment_policy< 1, 1, primitive_id_stack >
 * @brief Partial policy specialization for assignment expression <tt>S=R</tt>.
 *
 @code
    S=R
 @endcode
 * where S is an instance of cttl_impl::xst_stack lambda primitive.
 *
 */
template<>
struct xst_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_stack > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_assignment;

    /**Implementation of assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>S=R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( = " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,S_=1,istack>" );
        typename LambdaLhsT::value_T rhs_value( rhs_lambda_.top( const_scalar( 0 ) ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->push( const_scalar( 0 ), rhs_value );
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return rhs_value;
    }

    /**Fulfills prefix side effects for lambda expresion <tt>S=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>S=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>S=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>S=R</tt> succeeds if integral result of lambda
    *    expression <tt>S=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_assignment_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:127
// generated by bin\gmu\gmu_lambda\operators/assign/stack_multipush_assignment_adaptor.h:1

/**@struct xst_stack_inserter
 * @brief Helper function object to push values to stack.
 *
 * @tparam StackT
 *        specifies value type of
 *        <a href="http://www.sgi.com/tech/stl/stack.html">stack</a>.
 *
 */
template< typename StackT >
struct xst_stack_inserter
{
    /**Mutable reference to stack object.*/
    StackT& m_stack;

    /**Constructs and initializes the instance.*/
    xst_stack_inserter( StackT& stack_ )
        :
    m_stack( stack_ )
    {
    }

private:
    /**Assignment is disabled.*/
    xst_stack_inserter< StackT >& operator=( xst_stack_inserter< StackT > const& );

public:
    /**Push value of tree terminal node to stack.
    *
    * @tparam TerminalT
    *        specifies value type of tree node.
    *
    */
    template< typename TerminalT >
    void operator() ( TerminalT const& terminal_ )
    {
        m_stack.push( terminal_.top( const_scalar( 0 ) ) );
    }

}; // struct xst_stack_inserter

// S=M -> A<M_,S_=1,istack>, where A := xst_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_stack >

/**@struct xst_assignment_policy< RhsCapacityT, 1, primitive_id_stack >
 * @brief Partial policy specialization for assignment expression <tt>S=M</tt>.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 @code
    S=M
 @endcode
 * where S is an instance of cttl_impl::xst_stack lambda primitive.
 *
 */
template< int RhsCapacityT >
struct xst_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_stack > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_assignment;

    /**Implementation of assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>S=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( = (" );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,S_=1,istack>" );
        xst_stack_inserter< std::stack< typename LambdaLhsT::value_T > > inserter(
            *( const_cast< LambdaLhsT* >( &lhs_lambda_ )->stack_ptr( const_scalar( 0 ) ) )
            );
        const_cast< LambdaRhsT* >( &rhs_lambda_ )->traverse_top_down( inserter );
        CTTL_TRACE_DEPOSIT_TEXT( ") -> " );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Fulfills prefix side effects for lambda expresion <tt>S=M</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>S=M</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>S=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>S=M</tt> succeeds if integral result of lambda
    *    expression <tt>S=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_assignment_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:793
// generated by bin/gmu/gmu_lambda/gmu_common.h:147
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_translator.h:1

// T=R -> A<R_=1,T_=1,itran>, where A := xst_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_translator >

/**@struct xst_assignment_policy< 1, 1, primitive_id_translator >
 * @brief policy specialization for binary <tt>T=R</tt> lambda expressions.
 *
 @code
    T=R
 @endcode
 * where T is an instance of cttl_impl::xst_translator.
 *
 */
template<>
struct xst_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_translator > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_assignment;

    /**Implementation of assignment assignment operator for
    *  lambda expression <tt>T=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns integer evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( = " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,T_=1,itran>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->push(
            const_scalar( 0 ),
            rhs_lambda_.top( const_scalar( 0 ) )
            );
        return lhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of assignment to T is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Assignment side effect is the assignment itself.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Assignment has no post side effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>T=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>T=R</tt> succeeds if integral result of lambda
    *    expression <tt>T=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:798
// generated by bin/gmu/gmu_lambda/gmu_common.h:137
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_void.h:1

// *V=R -> A<R_=1,V_=0,id>, where A := xst_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/0, primitive_id_unary_adaptor >

/**@struct xst_assignment_policy< 1, 0, primitive_id_unary_adaptor >
 * @brief policy specialization for binary <tt>*V=R</tt> lambda expressions.
 *
 @code
    *V=R
 @endcode
 * where V is an instance of lvalue-only type, such as
 * <a href="http://www.sgi.com/tech/stl/OutputIterator.html">output iterator</a>.
 * The left-hand-side lvalue-only type is indicated by zero capacity.
 *
 */
template<>
struct xst_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/0, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_assignment_2_void;

    /**Implementation of assignment assignment operator for
    *  lambda expression <tt>*V=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @pre
    *        Please note that left-hand side must be dereferenceable.
    *
    * @return
    *        Hardcoded value of 1 (result is not used).
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    int
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( = " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,V_=0,id>" );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->prefix_side_effects();    // fulfill side effects
        // Note usage of dereference operator: left operand must be
        // dereferenced before it can be assigned:
        *( const_cast< LambdaLhsT* >( &lhs_lambda_ )->lvalue_ref() ) = rhs_lambda_.top( const_scalar( 0 ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return 1; // result is not used
    }

    /**Fulfills prefix side effects for lambda expresion <tt>*V=R</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>*V=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>*V=R</tt> always succeeds.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_assignment_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:812
// generated by bin/gmu/gmu_lambda/gmu_common.h:98
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:1
/**Primary template for cttt_impl::xst_multiplication_assignment_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_multiplication_assignment_policy {
};//xst_multiplication_assignment_policy

// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:7

// X*=R -> A<R_=1,X_=1,iscalar>, where A := xst_multiplication_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_multiplication_assignment_policy< 1, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X*=R</tt>.
 *
 @code
    X*=R
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template<>
struct xst_multiplication_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of multiplication assignment assignment operator for
    *  lambda expression <tt>X*=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( *= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) *= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X*=R</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X*=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X*=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X*=R</tt> succeeds if integral result of lambda
    *    expression <tt>X*=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_multiplication_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:101
// generated by bin\gmu\gmu_lambda\operators/assign/multi_assignment_adaptor_struct.h:1

// X*=M -> A<M_,X_=1,id>, where A := xst_multiplication_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_multiplication_assignment_policy< RhsCapacityT, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X*=M</tt>.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 @code
    X*=M
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template< int RhsCapacityT >//, int PrimitiveIdT > 
struct xst_multiplication_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of multiplication assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X*=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( *= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) *= rhs_lambda_;
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X*=M</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X*=M</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X*=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X*=M</tt> succeeds if integral result of lambda
    *    expression <tt>X*=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_multiplication_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:104
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_unary_adaptors.h:1

// U*=R -> A<R_,U_,iunary>, where A := xst_multiplication_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >

/**@struct xst_multiplication_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >
 * @brief policy specialization for binary <tt>U*=R</tt> lambda expressions.
 *
 @code
    U*=R
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the
 *        left-hand-side unary operator policy.
 *
 */
template< int RhsCapacityT, int LhsCapacityT >
struct xst_multiplication_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of multiplication assignment assignment operator for
    *  lambda expression <tt>U*=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( *= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->prefix_side_effects();
        typename LambdaLhsT::value_T lhs_value = ( const_cast< LambdaLhsT* >( &lhs_lambda_ )->lvalue_ref() *= rhs_lambda_.top( const_scalar( 0 ) ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return lhs_value;
    }

    /**Lvalue support: result of assignment to U is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U*=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * The implementation is similar to <tt>top()</tt> but excludes left-hand-side
    * postfix side effects does not return any value.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( *= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        lhs_lambda_.prefix_side_effects();
        lhs_lambda_.lvalue_ref() *= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U*=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& lhs_lambda_ )
    {
        lhs_lambda_.postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U*=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U*=R</tt> succeeds if integral result of lambda
    *    expression <tt>U*=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_multiplication_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:822
// generated by bin/gmu/gmu_lambda/gmu_common.h:98
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:1
/**Primary template for cttt_impl::xst_division_assignment_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_division_assignment_policy {
};//xst_division_assignment_policy

// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:7

// X/=R -> A<R_=1,X_=1,iscalar>, where A := xst_division_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_division_assignment_policy< 1, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X/=R</tt>.
 *
 @code
    X/=R
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template<>
struct xst_division_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of division assignment assignment operator for
    *  lambda expression <tt>X/=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( /= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) /= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X/=R</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X/=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X/=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X/=R</tt> succeeds if integral result of lambda
    *    expression <tt>X/=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_division_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:101
// generated by bin\gmu\gmu_lambda\operators/assign/multi_assignment_adaptor_struct.h:1

// X/=M -> A<M_,X_=1,id>, where A := xst_division_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_division_assignment_policy< RhsCapacityT, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X/=M</tt>.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 @code
    X/=M
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template< int RhsCapacityT >//, int PrimitiveIdT > 
struct xst_division_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of division assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X/=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( /= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) /= rhs_lambda_;
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X/=M</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X/=M</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X/=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X/=M</tt> succeeds if integral result of lambda
    *    expression <tt>X/=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_division_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:104
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_unary_adaptors.h:1

// U/=R -> A<R_,U_,iunary>, where A := xst_division_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >

/**@struct xst_division_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >
 * @brief policy specialization for binary <tt>U/=R</tt> lambda expressions.
 *
 @code
    U/=R
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the
 *        left-hand-side unary operator policy.
 *
 */
template< int RhsCapacityT, int LhsCapacityT >
struct xst_division_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of division assignment assignment operator for
    *  lambda expression <tt>U/=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( /= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->prefix_side_effects();
        typename LambdaLhsT::value_T lhs_value = ( const_cast< LambdaLhsT* >( &lhs_lambda_ )->lvalue_ref() /= rhs_lambda_.top( const_scalar( 0 ) ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return lhs_value;
    }

    /**Lvalue support: result of assignment to U is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U/=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * The implementation is similar to <tt>top()</tt> but excludes left-hand-side
    * postfix side effects does not return any value.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( /= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        lhs_lambda_.prefix_side_effects();
        lhs_lambda_.lvalue_ref() /= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U/=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& lhs_lambda_ )
    {
        lhs_lambda_.postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U/=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U/=R</tt> succeeds if integral result of lambda
    *    expression <tt>U/=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_division_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:832
// generated by bin/gmu/gmu_lambda/gmu_common.h:98
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:1
/**Primary template for cttt_impl::xst_modulus_assignment_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_modulus_assignment_policy {
};//xst_modulus_assignment_policy

// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:7

// X%=R -> A<R_=1,X_=1,iscalar>, where A := xst_modulus_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_modulus_assignment_policy< 1, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X%=R</tt>.
 *
 @code
    X%=R
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template<>
struct xst_modulus_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of modulus assignment assignment operator for
    *  lambda expression <tt>X%=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( %= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) %= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X%=R</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X%=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X%=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X%=R</tt> succeeds if integral result of lambda
    *    expression <tt>X%=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_modulus_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:101
// generated by bin\gmu\gmu_lambda\operators/assign/multi_assignment_adaptor_struct.h:1

// X%=M -> A<M_,X_=1,id>, where A := xst_modulus_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_modulus_assignment_policy< RhsCapacityT, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X%=M</tt>.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 @code
    X%=M
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template< int RhsCapacityT >//, int PrimitiveIdT > 
struct xst_modulus_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of modulus assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X%=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( %= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) %= rhs_lambda_;
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X%=M</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X%=M</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X%=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X%=M</tt> succeeds if integral result of lambda
    *    expression <tt>X%=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_modulus_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:104
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_unary_adaptors.h:1

// U%=R -> A<R_,U_,iunary>, where A := xst_modulus_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >

/**@struct xst_modulus_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >
 * @brief policy specialization for binary <tt>U%=R</tt> lambda expressions.
 *
 @code
    U%=R
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the
 *        left-hand-side unary operator policy.
 *
 */
template< int RhsCapacityT, int LhsCapacityT >
struct xst_modulus_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of modulus assignment assignment operator for
    *  lambda expression <tt>U%=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( %= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->prefix_side_effects();
        typename LambdaLhsT::value_T lhs_value = ( const_cast< LambdaLhsT* >( &lhs_lambda_ )->lvalue_ref() %= rhs_lambda_.top( const_scalar( 0 ) ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return lhs_value;
    }

    /**Lvalue support: result of assignment to U is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U%=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * The implementation is similar to <tt>top()</tt> but excludes left-hand-side
    * postfix side effects does not return any value.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( %= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        lhs_lambda_.prefix_side_effects();
        lhs_lambda_.lvalue_ref() %= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U%=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& lhs_lambda_ )
    {
        lhs_lambda_.postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U%=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U%=R</tt> succeeds if integral result of lambda
    *    expression <tt>U%=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_modulus_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:842
// generated by bin/gmu/gmu_lambda/gmu_common.h:98
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:1
/**Primary template for cttt_impl::xst_addition_assignment_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_addition_assignment_policy {
};//xst_addition_assignment_policy

// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:7

// X+=R -> A<R_=1,X_=1,iscalar>, where A := xst_addition_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_addition_assignment_policy< 1, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X+=R</tt>.
 *
 @code
    X+=R
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template<>
struct xst_addition_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of addition assignment assignment operator for
    *  lambda expression <tt>X+=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( += " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) += rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X+=R</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X+=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X+=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X+=R</tt> succeeds if integral result of lambda
    *    expression <tt>X+=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_addition_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:101
// generated by bin\gmu\gmu_lambda\operators/assign/multi_assignment_adaptor_struct.h:1

// X+=M -> A<M_,X_=1,id>, where A := xst_addition_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_addition_assignment_policy< RhsCapacityT, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X+=M</tt>.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 @code
    X+=M
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template< int RhsCapacityT >//, int PrimitiveIdT > 
struct xst_addition_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of addition assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X+=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( += " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) += rhs_lambda_;
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X+=M</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X+=M</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X+=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X+=M</tt> succeeds if integral result of lambda
    *    expression <tt>X+=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_addition_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:104
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_unary_adaptors.h:1

// U+=R -> A<R_,U_,iunary>, where A := xst_addition_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >

/**@struct xst_addition_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >
 * @brief policy specialization for binary <tt>U+=R</tt> lambda expressions.
 *
 @code
    U+=R
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the
 *        left-hand-side unary operator policy.
 *
 */
template< int RhsCapacityT, int LhsCapacityT >
struct xst_addition_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of addition assignment assignment operator for
    *  lambda expression <tt>U+=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( += " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->prefix_side_effects();
        typename LambdaLhsT::value_T lhs_value = ( const_cast< LambdaLhsT* >( &lhs_lambda_ )->lvalue_ref() += rhs_lambda_.top( const_scalar( 0 ) ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return lhs_value;
    }

    /**Lvalue support: result of assignment to U is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U+=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * The implementation is similar to <tt>top()</tt> but excludes left-hand-side
    * postfix side effects does not return any value.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( += " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        lhs_lambda_.prefix_side_effects();
        lhs_lambda_.lvalue_ref() += rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U+=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& lhs_lambda_ )
    {
        lhs_lambda_.postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U+=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U+=R</tt> succeeds if integral result of lambda
    *    expression <tt>U+=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_addition_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:852
// generated by bin/gmu/gmu_lambda/gmu_common.h:98
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:1
/**Primary template for cttt_impl::xst_subtraction_assignment_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_subtraction_assignment_policy {
};//xst_subtraction_assignment_policy

// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:7

// X-=R -> A<R_=1,X_=1,iscalar>, where A := xst_subtraction_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_subtraction_assignment_policy< 1, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X-=R</tt>.
 *
 @code
    X-=R
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template<>
struct xst_subtraction_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of subtraction assignment assignment operator for
    *  lambda expression <tt>X-=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( -= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) -= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X-=R</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X-=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X-=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X-=R</tt> succeeds if integral result of lambda
    *    expression <tt>X-=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_subtraction_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:101
// generated by bin\gmu\gmu_lambda\operators/assign/multi_assignment_adaptor_struct.h:1

// X-=M -> A<M_,X_=1,id>, where A := xst_subtraction_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_subtraction_assignment_policy< RhsCapacityT, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X-=M</tt>.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 @code
    X-=M
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template< int RhsCapacityT >//, int PrimitiveIdT > 
struct xst_subtraction_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of subtraction assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X-=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( -= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) -= rhs_lambda_;
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X-=M</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X-=M</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X-=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X-=M</tt> succeeds if integral result of lambda
    *    expression <tt>X-=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_subtraction_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:104
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_unary_adaptors.h:1

// U-=R -> A<R_,U_,iunary>, where A := xst_subtraction_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >

/**@struct xst_subtraction_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >
 * @brief policy specialization for binary <tt>U-=R</tt> lambda expressions.
 *
 @code
    U-=R
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the
 *        left-hand-side unary operator policy.
 *
 */
template< int RhsCapacityT, int LhsCapacityT >
struct xst_subtraction_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of subtraction assignment assignment operator for
    *  lambda expression <tt>U-=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( -= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->prefix_side_effects();
        typename LambdaLhsT::value_T lhs_value = ( const_cast< LambdaLhsT* >( &lhs_lambda_ )->lvalue_ref() -= rhs_lambda_.top( const_scalar( 0 ) ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return lhs_value;
    }

    /**Lvalue support: result of assignment to U is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U-=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * The implementation is similar to <tt>top()</tt> but excludes left-hand-side
    * postfix side effects does not return any value.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( -= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        lhs_lambda_.prefix_side_effects();
        lhs_lambda_.lvalue_ref() -= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U-=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& lhs_lambda_ )
    {
        lhs_lambda_.postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U-=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U-=R</tt> succeeds if integral result of lambda
    *    expression <tt>U-=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_subtraction_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:862
// generated by bin/gmu/gmu_lambda/gmu_common.h:98
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:1
/**Primary template for cttt_impl::xst_left_shift_assignment_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_left_shift_assignment_policy {
};//xst_left_shift_assignment_policy

// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:7

// X<<=R -> A<R_=1,X_=1,iscalar>, where A := xst_left_shift_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_left_shift_assignment_policy< 1, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X<<=R</tt>.
 *
 @code
    X<<=R
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template<>
struct xst_left_shift_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of left shift assignment assignment operator for
    *  lambda expression <tt>X<<=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( <<= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) <<= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X<<=R</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X<<=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X<<=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X<<=R</tt> succeeds if integral result of lambda
    *    expression <tt>X<<=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_left_shift_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:101
// generated by bin\gmu\gmu_lambda\operators/assign/multi_assignment_adaptor_struct.h:1

// X<<=M -> A<M_,X_=1,id>, where A := xst_left_shift_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_left_shift_assignment_policy< RhsCapacityT, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X<<=M</tt>.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 @code
    X<<=M
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template< int RhsCapacityT >//, int PrimitiveIdT > 
struct xst_left_shift_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of left shift assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X<<=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( <<= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) <<= rhs_lambda_;
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X<<=M</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X<<=M</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X<<=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X<<=M</tt> succeeds if integral result of lambda
    *    expression <tt>X<<=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_left_shift_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:104
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_unary_adaptors.h:1

// U<<=R -> A<R_,U_,iunary>, where A := xst_left_shift_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >

/**@struct xst_left_shift_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >
 * @brief policy specialization for binary <tt>U<<=R</tt> lambda expressions.
 *
 @code
    U<<=R
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the
 *        left-hand-side unary operator policy.
 *
 */
template< int RhsCapacityT, int LhsCapacityT >
struct xst_left_shift_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of left shift assignment assignment operator for
    *  lambda expression <tt>U<<=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( <<= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->prefix_side_effects();
        typename LambdaLhsT::value_T lhs_value = ( const_cast< LambdaLhsT* >( &lhs_lambda_ )->lvalue_ref() <<= rhs_lambda_.top( const_scalar( 0 ) ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return lhs_value;
    }

    /**Lvalue support: result of assignment to U is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U<<=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * The implementation is similar to <tt>top()</tt> but excludes left-hand-side
    * postfix side effects does not return any value.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( <<= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        lhs_lambda_.prefix_side_effects();
        lhs_lambda_.lvalue_ref() <<= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U<<=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& lhs_lambda_ )
    {
        lhs_lambda_.postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U<<=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U<<=R</tt> succeeds if integral result of lambda
    *    expression <tt>U<<=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_left_shift_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:873
// generated by bin/gmu/gmu_lambda/gmu_common.h:98
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:1
/**Primary template for cttt_impl::xst_right_shift_assignment_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_right_shift_assignment_policy {
};//xst_right_shift_assignment_policy

// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:7

// X>>=R -> A<R_=1,X_=1,iscalar>, where A := xst_right_shift_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_right_shift_assignment_policy< 1, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X>>=R</tt>.
 *
 @code
    X>>=R
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template<>
struct xst_right_shift_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of right shift assignment assignment operator for
    *  lambda expression <tt>X>>=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( >>= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) >>= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X>>=R</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X>>=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X>>=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X>>=R</tt> succeeds if integral result of lambda
    *    expression <tt>X>>=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_right_shift_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:101
// generated by bin\gmu\gmu_lambda\operators/assign/multi_assignment_adaptor_struct.h:1

// X>>=M -> A<M_,X_=1,id>, where A := xst_right_shift_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_right_shift_assignment_policy< RhsCapacityT, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X>>=M</tt>.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 @code
    X>>=M
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template< int RhsCapacityT >//, int PrimitiveIdT > 
struct xst_right_shift_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of right shift assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X>>=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( >>= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) >>= rhs_lambda_;
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X>>=M</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X>>=M</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X>>=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X>>=M</tt> succeeds if integral result of lambda
    *    expression <tt>X>>=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_right_shift_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:104
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_unary_adaptors.h:1

// U>>=R -> A<R_,U_,iunary>, where A := xst_right_shift_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >

/**@struct xst_right_shift_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >
 * @brief policy specialization for binary <tt>U>>=R</tt> lambda expressions.
 *
 @code
    U>>=R
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the
 *        left-hand-side unary operator policy.
 *
 */
template< int RhsCapacityT, int LhsCapacityT >
struct xst_right_shift_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of right shift assignment assignment operator for
    *  lambda expression <tt>U>>=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( >>= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->prefix_side_effects();
        typename LambdaLhsT::value_T lhs_value = ( const_cast< LambdaLhsT* >( &lhs_lambda_ )->lvalue_ref() >>= rhs_lambda_.top( const_scalar( 0 ) ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return lhs_value;
    }

    /**Lvalue support: result of assignment to U is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U>>=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * The implementation is similar to <tt>top()</tt> but excludes left-hand-side
    * postfix side effects does not return any value.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( >>= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        lhs_lambda_.prefix_side_effects();
        lhs_lambda_.lvalue_ref() >>= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U>>=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& lhs_lambda_ )
    {
        lhs_lambda_.postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U>>=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U>>=R</tt> succeeds if integral result of lambda
    *    expression <tt>U>>=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_right_shift_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:883
// generated by bin/gmu/gmu_lambda/gmu_common.h:98
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:1
/**Primary template for cttt_impl::xst_bitwise_and_assignment_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_bitwise_and_assignment_policy {
};//xst_bitwise_and_assignment_policy

// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:7

// X&=R -> A<R_=1,X_=1,iscalar>, where A := xst_bitwise_and_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_and_assignment_policy< 1, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X&=R</tt>.
 *
 @code
    X&=R
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template<>
struct xst_bitwise_and_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of bitwise and assignment assignment operator for
    *  lambda expression <tt>X&=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( &= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) &= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X&=R</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X&=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X&=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X&=R</tt> succeeds if integral result of lambda
    *    expression <tt>X&=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_and_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:101
// generated by bin\gmu\gmu_lambda\operators/assign/multi_assignment_adaptor_struct.h:1

// X&=M -> A<M_,X_=1,id>, where A := xst_bitwise_and_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_and_assignment_policy< RhsCapacityT, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X&=M</tt>.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 @code
    X&=M
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template< int RhsCapacityT >//, int PrimitiveIdT > 
struct xst_bitwise_and_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of bitwise and assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X&=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( &= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) &= rhs_lambda_;
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X&=M</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X&=M</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X&=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X&=M</tt> succeeds if integral result of lambda
    *    expression <tt>X&=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_and_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:104
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_unary_adaptors.h:1

// U&=R -> A<R_,U_,iunary>, where A := xst_bitwise_and_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >

/**@struct xst_bitwise_and_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >
 * @brief policy specialization for binary <tt>U&=R</tt> lambda expressions.
 *
 @code
    U&=R
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the
 *        left-hand-side unary operator policy.
 *
 */
template< int RhsCapacityT, int LhsCapacityT >
struct xst_bitwise_and_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of bitwise and assignment assignment operator for
    *  lambda expression <tt>U&=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( &= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->prefix_side_effects();
        typename LambdaLhsT::value_T lhs_value = ( const_cast< LambdaLhsT* >( &lhs_lambda_ )->lvalue_ref() &= rhs_lambda_.top( const_scalar( 0 ) ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return lhs_value;
    }

    /**Lvalue support: result of assignment to U is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U&=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * The implementation is similar to <tt>top()</tt> but excludes left-hand-side
    * postfix side effects does not return any value.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( &= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        lhs_lambda_.prefix_side_effects();
        lhs_lambda_.lvalue_ref() &= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U&=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& lhs_lambda_ )
    {
        lhs_lambda_.postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U&=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U&=R</tt> succeeds if integral result of lambda
    *    expression <tt>U&=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_and_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:893
// generated by bin/gmu/gmu_lambda/gmu_common.h:98
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:1
/**Primary template for cttt_impl::xst_bitwise_ior_assignment_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_bitwise_ior_assignment_policy {
};//xst_bitwise_ior_assignment_policy

// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:7

// X|=R -> A<R_=1,X_=1,iscalar>, where A := xst_bitwise_ior_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_ior_assignment_policy< 1, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X|=R</tt>.
 *
 @code
    X|=R
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template<>
struct xst_bitwise_ior_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of bitwise inclusive or assignment assignment operator for
    *  lambda expression <tt>X|=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( |= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) |= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X|=R</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X|=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X|=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X|=R</tt> succeeds if integral result of lambda
    *    expression <tt>X|=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_ior_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:101
// generated by bin\gmu\gmu_lambda\operators/assign/multi_assignment_adaptor_struct.h:1

// X|=M -> A<M_,X_=1,id>, where A := xst_bitwise_ior_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_ior_assignment_policy< RhsCapacityT, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X|=M</tt>.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 @code
    X|=M
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template< int RhsCapacityT >//, int PrimitiveIdT > 
struct xst_bitwise_ior_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of bitwise inclusive or assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X|=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( |= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) |= rhs_lambda_;
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X|=M</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X|=M</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X|=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X|=M</tt> succeeds if integral result of lambda
    *    expression <tt>X|=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_ior_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:104
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_unary_adaptors.h:1

// U|=R -> A<R_,U_,iunary>, where A := xst_bitwise_ior_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >

/**@struct xst_bitwise_ior_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >
 * @brief policy specialization for binary <tt>U|=R</tt> lambda expressions.
 *
 @code
    U|=R
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the
 *        left-hand-side unary operator policy.
 *
 */
template< int RhsCapacityT, int LhsCapacityT >
struct xst_bitwise_ior_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of bitwise inclusive or assignment assignment operator for
    *  lambda expression <tt>U|=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( |= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->prefix_side_effects();
        typename LambdaLhsT::value_T lhs_value = ( const_cast< LambdaLhsT* >( &lhs_lambda_ )->lvalue_ref() |= rhs_lambda_.top( const_scalar( 0 ) ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return lhs_value;
    }

    /**Lvalue support: result of assignment to U is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U|=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * The implementation is similar to <tt>top()</tt> but excludes left-hand-side
    * postfix side effects does not return any value.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( |= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        lhs_lambda_.prefix_side_effects();
        lhs_lambda_.lvalue_ref() |= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U|=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& lhs_lambda_ )
    {
        lhs_lambda_.postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U|=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U|=R</tt> succeeds if integral result of lambda
    *    expression <tt>U|=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_ior_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:903
// generated by bin/gmu/gmu_lambda/gmu_common.h:98
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:1
/**Primary template for cttt_impl::xst_bitwise_xor_assignment_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_bitwise_xor_assignment_policy {
};//xst_bitwise_xor_assignment_policy

// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_struct.h:7

// X^=R -> A<R_=1,X_=1,iscalar>, where A := xst_bitwise_xor_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_xor_assignment_policy< 1, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X^=R</tt>.
 *
 @code
    X^=R
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template<>
struct xst_bitwise_xor_assignment_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of bitwise exclusive or assignment assignment operator for
    *  lambda expression <tt>X^=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( ^= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) ^= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X^=R</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X^=R</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X^=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X^=R</tt> succeeds if integral result of lambda
    *    expression <tt>X^=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_xor_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:101
// generated by bin\gmu\gmu_lambda\operators/assign/multi_assignment_adaptor_struct.h:1

// X^=M -> A<M_,X_=1,id>, where A := xst_bitwise_xor_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_xor_assignment_policy< RhsCapacityT, 1, primitive_id_scalar >
 * @brief policy specialization for assignment expression <tt>X^=M</tt>.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 @code
    X^=M
 @endcode
 * where X is an instance of lambda primitive.
 *
 */
template< int RhsCapacityT >//, int PrimitiveIdT > 
struct xst_bitwise_xor_assignment_policy< RhsCapacityT, /*LhsCapacityT*/1, primitive_id_scalar > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of bitwise exclusive or assignment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X^=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( ^= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,X_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return const_cast< LambdaLhsT* >( &lhs_lambda_ )->top( const_scalar( 0 ) ) ^= rhs_lambda_;
    }

    /**Lvalue support: result of assignment to X is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>X^=M</tt>.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        top( lhs_lambda_, rhs_lambda_ );
    }

    /**Lambda expresion <tt>X^=M</tt> has no post effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X^=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X^=M</tt> succeeds if integral result of lambda
    *    expression <tt>X^=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_xor_assignment_policy
// generated by bin/gmu/gmu_lambda/gmu_common.h:104
// generated by bin\gmu\gmu_lambda\operators/assign/assignment_adaptor_4_unary_adaptors.h:1

// U^=R -> A<R_,U_,iunary>, where A := xst_bitwise_xor_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >

/**@struct xst_bitwise_xor_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor >
 * @brief policy specialization for binary <tt>U^=R</tt> lambda expressions.
 *
 @code
    U^=R
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the
 *        left-hand-side unary operator policy.
 *
 */
template< int RhsCapacityT, int LhsCapacityT >
struct xst_bitwise_xor_assignment_policy< RhsCapacityT, LhsCapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic_assignment;

    /**Implementation of bitwise exclusive or assignment assignment operator for
    *  lambda expression <tt>U^=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of the assignment expression.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( ^= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->prefix_side_effects();
        typename LambdaLhsT::value_T lhs_value = ( const_cast< LambdaLhsT* >( &lhs_lambda_ )->lvalue_ref() ^= rhs_lambda_.top( const_scalar( 0 ) ) );
        const_cast< LambdaLhsT* >( &lhs_lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
        return lhs_value;
    }

    /**Lvalue support: result of assignment to U is lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to left operand.
    *
    */
    template< typename LambdaLhsT >
    static
    typename LambdaLhsT::value_T&
    lvalue_ref( LambdaLhsT& lhs_lambda_ )
    {
        return lhs_lambda_.lvalue_ref();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U^=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * The implementation is similar to <tt>top()</tt> but excludes left-hand-side
    * postfix side effects does not return any value.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( ^= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_,U_,iunary>" );
        lhs_lambda_.prefix_side_effects();
        lhs_lambda_.lvalue_ref() ^= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U^=R</tt>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    */
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& lhs_lambda_ )
    {
        lhs_lambda_.postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ')' );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U^=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U^=R</tt> succeeds if integral result of lambda
    *    expression <tt>U^=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_xor_assignment_policy

}   // namespace cttl_impl


#endif //_XST_ASSIGNMENT_ADAPTORS_H_INCLUDED_
