////////////////////////////////////////////////////////////////////////
//
// This file is part of Common Text Transformation Library.
// Copyright (C) 1997-2009 by Igor Kholodov. 
//
// Common Text Transformation Library is free software: you can
// redistribute it and/or modify it under the terms of the
// GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Common Text Transformation Library is distributed in the hope
// that it will be useful, but WITHOUT ANY WARRANTY; without even
// the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
// PURPOSE.  See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with Common Text Transformation Library.
// If not, see <http://www.gnu.org/licenses/>.
//
// mailto:cttl@users.sourceforge.net
// http://cttl.sourceforge.net/
// http://sourceforge.net/projects/cttl/
//
////////////////////////////////////////////////////////////////////////

/**@file xst_operator_traits.h
 * @brief Defines lambda operator traits.
 *
 * This file was generated by gumus script on Sun Aug 16 21:52:48 2009.
 *
 * @warning
 *      This is internal CTTL header file and should not
 *      be included by user programs.
 *
 */

// xst_operator_traits.h

#ifndef _XST_OPERATOR_TRAITS_H_INCLUDED_
#define _XST_OPERATOR_TRAITS_H_INCLUDED_

namespace cttl_impl {

// generated by bin/gmu/gmu_lambda/gmu_common.h:929

// generated by bin\gmu\gmu_lambda\operator_traits.h:24
// primitive ids identify categories of lambda primitives

/**Unspecified lambda primitive id.
*
* @remarks
* Sometimes specialized version of operator policy needs to call unspecialized
* version of the same policy primary template. In such case, this constant is used.
* For example, all dereference operator policy specializations invoke
* unspecialized version of @c match() member function, since kleene star preempts dereference.
*
*/
const int primitive_id_unspecified    = 0;

/**Identifies cttl_impl::xst_const_scalar template.*/
const int primitive_id_const_scalar   = 1;

/**Identifies cttl_impl::xst_scalar template.*/
const int primitive_id_scalar         = 2;

/**Identifies cttl_impl::xst_stack template.*/
const int primitive_id_stack          = 4;

/**Identifies cttl_impl::xst_translator template.*/
const int primitive_id_translator     = 8;

/**Identifies cttl_impl::xst_unary_adaptor template.*/
const int primitive_id_unary_adaptor  = 16;

/**Identifies cttl_impl::xst_binary_adaptor template.*/
const int primitive_id_binary_adaptor = 32;

// generated by bin\gmu\gmu_lambda\operator_traits.h:56
// operator ids identify categories of operators

/**Identifies all dereference operators.*/
const int operator_id_dereference             = 1;

/**Identifies unary and binary logical operators returning boolean values, such as binary == and unary !.*/
const int operator_id_bool                    = 2;

/**Identifies assignment operators.*/
const int operator_id_assignment              = 3;

/**Identifies arithmetic assignment operators.*/
const int operator_id_arithmetic_assignment   = 4;

/**Identifies arithmetic operators.*/
const int operator_id_arithmetic              = 5;

/**Identifies stack-- operators.*/
const int operator_id_stack_postfix_decrement = 6;

/**Identifies +stack operators.*/
const int operator_id_stack_unary_plus        = 7;

/**Identifies prefix increment operators.*/
const int operator_id_prefix_increment       =  8;

/**Identifies prefix decrement operators.*/
const int operator_id_prefix_decrement       =  9;

/**Identifies comma operator.*/
const int operator_id_comma                  = 10;

/**Identifies assignment to dereferenced output iterator.*/
const int operator_id_assignment_2_void      = 11;

/**Identifies subscript operator.*/
const int operator_id_subscript              = 12;

/**Identifies --stack operators.*/
const int operator_id_stack_prefix_decrement = 13;


//-------------------------------------------------------------------------
// Dereference traits
//-------------------------------------------------------------------------

/**@struct xst_dereference_traits
 * @brief Implements primary template describing dereference operator traits.
 *
 * @tparam ValueT
 *        specifies type of the object X.
 *
 * @tparam DereferencedValueT
 *        specifies type of the dereferenced object *X.
 *
 */
template< typename ValueT, typename DereferencedValueT >
struct xst_dereference_traits
{
    /**Singular capacity suggests capability of *X being rvalue and lvalue.*/
    static const int capacity_ = 1;

    /**Type of *X is exposed as @c value_type.*/
    typedef DereferencedValueT value_type;

    /**Implements dereference algorithm.*/
    static DereferencedValueT& dereference( ValueT& value_ )
    {
        return *value_;
    }

}; // struct xst_dereference_traits


/**@struct xst_dereference_traits< ValueT, void >
 * @brief Implements template specialization describing dereference traits of output iterators.
 *
 * @tparam ValueT
 *        specifies type of
 *        <a href="http://www.sgi.com/tech/stl/OutputIterator.html">output iterator</a> X.
 *
 */
template< typename ValueT >
struct xst_dereference_traits< ValueT, void >
{
    /**Zero capacity suggests capability of *X being only an lvalue: result of <tt>*x = t</tt> is not used.*/
    static const int capacity_ = 0;

    /**Type of X is exposed as @c value_type.*/
    typedef ValueT value_type;

    /**Implements dereference algorithm which does nothing.*/
    static ValueT& dereference( ValueT& value_ )
    {
        return value_;
    }


}; // struct xst_dereference_traits


/**@struct xst_dereference_traits< ValueT, DereferencedValueT& >
 * @brief Implements partially specialized template for references.
 *
 * @tparam ValueT
 *        specifies type of the object X.
 *
 * @tparam DereferencedValueT
 *        specifies type of the dereferenced object *X.
 *
 */
template< typename ValueT, typename DereferencedValueT >
struct xst_dereference_traits< ValueT, DereferencedValueT& >
{
    /**Singular capacity suggests capability of *X being rvalue and lvalue.*/
    static const int capacity_ = 1;

    /**Type of *X is exposed as @c value_type.*/
    typedef DereferencedValueT value_type;

    /**Implements dereference algorithm.*/
    static DereferencedValueT& dereference( ValueT& value_ )
    {
        return *value_;
    }

}; // struct xst_dereference_traits


//-------------------------------------------------------------------------
// Non-scalar traits
//-------------------------------------------------------------------------
// generated by bin\gmu\gmu_lambda\operator_traits.h:189

/**@struct xst_non_scalar_traits
 * @brief Implements primary template for compound objects of C++.
 *
 * @tparam ValueT
 *        specifies type of the object X.
 *
 */
template< typename ValueT >
struct xst_non_scalar_traits
{
    /**It is required that ValueT provides @c value_type typedef.*/
    typedef typename ValueT::value_type value_type;

    /**Since instance of ValueT cannot be identified as a value, use question mark to identify its value.*/
    static char identity( ValueT const& )
    {
        return '?';
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< bool >
 * @brief Implements template specialization for <tt>bool</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< bool >
{
    typedef bool value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< char >
 * @brief Implements template specialization for <tt>char</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< char >
{
    typedef char value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< signed char >
 * @brief Implements template specialization for <tt>signed char</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< signed char >
{
    typedef signed char value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< unsigned char >
 * @brief Implements template specialization for <tt>unsigned char</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< unsigned char >
{
    typedef unsigned char value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< short >
 * @brief Implements template specialization for <tt>short</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< short >
{
    typedef short value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< unsigned short >
 * @brief Implements template specialization for <tt>unsigned short</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< unsigned short >
{
    typedef unsigned short value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< int >
 * @brief Implements template specialization for <tt>int</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< int >
{
    typedef int value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< unsigned int >
 * @brief Implements template specialization for <tt>unsigned int</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< unsigned int >
{
    typedef unsigned int value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< long >
 * @brief Implements template specialization for <tt>long</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< long >
{
    typedef long value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< unsigned long >
 * @brief Implements template specialization for <tt>unsigned long</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< unsigned long >
{
    typedef unsigned long value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< float >
 * @brief Implements template specialization for <tt>float</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< float >
{
    typedef float value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< double >
 * @brief Implements template specialization for <tt>double</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< double >
{
    typedef double value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:215
/**@struct xst_non_scalar_traits< long double >
 * @brief Implements template specialization for <tt>long double</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< long double >
{
    typedef long double value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits


#if ( defined( _MSC_VER ) && _MSC_VER >= 1400 ) || !defined( _MSC_VER )
// generated by bin\gmu\gmu_lambda\operator_traits.h:235
// MSVC 8.0 defines _MSC_VER as 1400
// MSVC 7.x defines wchar_t as unsigned short, which has already been defined above

/**@struct xst_non_scalar_traits< wchar_t >
 * @brief Implements template specialization for @c wchar_t primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< wchar_t >
{
    typedef wchar_t value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

#endif // _MSC_VER


#if defined( _LONG_LONG )
// generated by bin\gmu\gmu_lambda\operator_traits.h:259

/**@struct xst_non_scalar_traits< long long >
 * @brief Implements template specialization for <tt>long long</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< long long >
{
    typedef long long value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

/**@struct xst_non_scalar_traits< unsigned long long >
 * @brief Implements template specialization for <tt>unsigned long long</tt> primitive type.
 *
 */
template<>
struct xst_non_scalar_traits< unsigned long long >
{
    typedef unsigned long long value_type;

    static value_type const& identity( value_type const& value_ )
    {
        return value_;
    }

}; // struct xst_non_scalar_traits

#endif // _LONG_LONG


// generated by bin\gmu\gmu_lambda\operator_traits.h:296

/**@struct xst_non_scalar_traits< void >
 * @brief Implements template specialization for @c void type.
 *
 */
template<>
struct xst_non_scalar_traits< void >
{
    typedef void value_type;

    template< typename IdentityValueT >
    static char identity( IdentityValueT const& )
    {
        return '?';
    }

}; // struct xst_non_scalar_traits


// generated by bin\gmu\gmu_lambda\operator_traits.h:316

/**@struct xst_non_scalar_traits< std::pair< FirstT, SecondT > >
 * @brief Implements template specialization for
 * <a href="http://www.sgi.com/tech/stl/pair.html"><tt>std::pair</tt></a> type.
 *
 */
template< typename FirstT, typename SecondT >
struct xst_non_scalar_traits< std::pair< FirstT, SecondT > >
{
    typedef std::pair< FirstT, SecondT > value_type;

    static char identity( value_type const& )
    {
        return '?';
    }

}; // struct xst_non_scalar_traits


// generated by bin\gmu\gmu_lambda\operator_traits.h:336

/**@struct xst_non_scalar_traits< ValueT& >
 * @brief Implements partial template specialization for mutable references.
 *
 */
template< typename ValueT >
struct xst_non_scalar_traits< ValueT& >
{
    typedef ValueT value_type;

    static char identity( ValueT& )
    {
        return '&';
    }

}; // struct xst_non_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:354

/**@struct xst_non_scalar_traits< ValueT const& >
 * @brief Implements partial template specialization for constant references.
 *
 */
template< typename ValueT >
struct xst_non_scalar_traits< ValueT const& >
{
    typedef ValueT value_type;

    static char identity( ValueT const& )
    {
        return '&';
    }

}; // struct xst_non_scalar_traits

//-------------------------------------------------------------------------
// Scalar traits
//-------------------------------------------------------------------------
// generated by bin\gmu\gmu_lambda\operator_traits.h:375

/**@struct xst_scalar_traits
 * @brief Implements primary template for scalar objects of C++.
 *
 * @tparam ValueT
 *        specifies type of the object X.
 *
 */
template< typename ValueT >
struct xst_scalar_traits
{
    static char identity( ValueT const& )
    {
        return '?';
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< bool >
 * @brief Implements template specialization for <tt>bool</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< bool >
{
    static bool const& identity( bool const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< char >
 * @brief Implements template specialization for <tt>char</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< char >
{
    static char const& identity( char const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< signed char >
 * @brief Implements template specialization for <tt>signed char</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< signed char >
{
    static signed char const& identity( signed char const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< unsigned char >
 * @brief Implements template specialization for <tt>unsigned char</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< unsigned char >
{
    static unsigned char const& identity( unsigned char const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< short >
 * @brief Implements template specialization for <tt>short</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< short >
{
    static short const& identity( short const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< unsigned short >
 * @brief Implements template specialization for <tt>unsigned short</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< unsigned short >
{
    static unsigned short const& identity( unsigned short const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< int >
 * @brief Implements template specialization for <tt>int</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< int >
{
    static int const& identity( int const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< unsigned int >
 * @brief Implements template specialization for <tt>unsigned int</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< unsigned int >
{
    static unsigned int const& identity( unsigned int const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< long >
 * @brief Implements template specialization for <tt>long</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< long >
{
    static long const& identity( long const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< unsigned long >
 * @brief Implements template specialization for <tt>unsigned long</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< unsigned long >
{
    static unsigned long const& identity( unsigned long const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< float >
 * @brief Implements template specialization for <tt>float</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< float >
{
    static float const& identity( float const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< double >
 * @brief Implements template specialization for <tt>double</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< double >
{
    static double const& identity( double const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:397

/**@struct xst_scalar_traits< long double >
 * @brief Implements template specialization for <tt>long double</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< long double >
{
    static long double const& identity( long double const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits


#if ( defined( _MSC_VER ) && _MSC_VER >= 1400 ) || !defined( _MSC_VER )
// generated by bin\gmu\gmu_lambda\operator_traits.h:416
// MSVC 8.0 defines _MSC_VER as 1400
// MSVC 7.x defines wchar_t as unsigned short, which has already been defined above

/**@struct xst_scalar_traits< wchar_t >
 * @brief Implements template specialization for @c wchar_t primitive type.
 *
 */
template<>
struct xst_scalar_traits< wchar_t >
{
    static wchar_t const& identity( wchar_t const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

#endif // _MSC_VER

#if defined( _LONG_LONG )
// generated by bin\gmu\gmu_lambda\operator_traits.h:437

/**@struct xst_scalar_traits< long long >
 * @brief Implements template specialization for <tt>long long</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< long long >
{
    static long long const& identity( long long const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

/**@struct xst_scalar_traits< unsigned long long >
 * @brief Implements template specialization for <tt>unsigned long long</tt> primitive type.
 *
 */
template<>
struct xst_scalar_traits< unsigned long long >
{
    static unsigned long long const& identity( unsigned long long const& value_ )
    {
        return value_;
    }

}; // struct xst_scalar_traits

#endif // _LONG_LONG


/**@struct xst_scalar_traits< void >
 * @brief Implements template specialization for @c void type.
 *
 */
template<>
struct xst_scalar_traits< void >
{
    template< typename IdentityValueT >
    static char identity( IdentityValueT const& )
    {
        return '?';
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:485

/**@struct xst_scalar_traits< ValueT& >
 * @brief Implements partial template specialization for mutable references.
 *
 */
template< typename ValueT >
struct xst_scalar_traits< ValueT& >
{
    static char identity( ValueT& )
    {
        return '&';
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:501

/**@struct xst_scalar_traits< ValueT const& >
 * @brief Implements partial template specialization for constant references.
 *
 */
template< typename ValueT >
struct xst_scalar_traits< ValueT const& >
{
    static char identity( ValueT const& )
    {
        return '&';
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:517

/**@struct xst_scalar_traits< ValueT* >
 * @brief Implements partial template specialization for mutable pointers.
 *
 */
template< typename ValueT >
struct xst_scalar_traits< ValueT* >
{
    static char identity( ValueT* )
    {
        return '*';
    }

}; // struct xst_scalar_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:533

/**@struct xst_scalar_traits< ValueT const* >
 * @brief Implements partial template specialization for constant pointers.
 *
 */
template< typename ValueT >
struct xst_scalar_traits< ValueT const* >
{
    static char identity( ValueT const* )
    {
        return '*';
    }

}; // struct xst_scalar_traits

//-------------------------------------------------------------------------
// Binary operator traits
//-------------------------------------------------------------------------
// generated by bin\gmu\gmu_lambda\operator_traits.h:552
//
// Binary operator adaptors choose the
// result type based on the two sides and the operator id.
// For logical operators, boolean type is chosen.

/////////////////////////////////////////////////////////////////
/////////////// unspecialized binary operator ///////////////////
/////////////////////////////////////////////////////////////////
/**@struct xst_binary_operator_traits
 * @brief Implements primary template describing traits of C++ binary operator.
 *
 * @tparam RhsValueT
 *        specifies right-hand-side type of the operator expression.
 *
 * @tparam LhsValueT
 *        specifies left-hand-side type of the operator expression.
 *
 * @tparam OperatorIdT
 *        specifies operator id (see above).
 *
 */
template< typename RhsValueT, typename LhsValueT, int OperatorIdT >
struct xst_binary_operator_traits
{
    /**In general, for most operators, first choice is @c LhsValueT type.*/ 
    typedef LhsValueT value_type;

}; // struct xst_binary_operator_traits


/////////////////////////////////////////////////////////////////
////////////////// binary comma operator ////////////////////////
/////////////////////////////////////////////////////////////////
/**@struct xst_binary_operator_traits< RhsValueT, LhsValueT, operator_id_comma >
 * @brief Implements partial template specialization for comma operator.
 *
 * @remarks
 * The comma operator allows grouping of lambda expressions:
 @code
        L,R 
 @endcode
 *
 * - The comma operator has left-to-right associativity.
 * - Two expressions separated by a comma are evaluated left to right.
 * - The left operand is always evaluated, and all side effects
 *   are completed before the right operand is evaluated.
 * - The type and value of the expression are the type and value of R.
 * - The result of evaluating L is discarded.
 * - The result is an rvalue obtained as a copy of the result of R.
 *
 */
template< typename RhsValueT, typename LhsValueT >
struct xst_binary_operator_traits< RhsValueT, LhsValueT, operator_id_comma >
{
    typedef RhsValueT value_type;

}; // struct xst_binary_operator_traits


/////////////////////////////////////////////////////////////////
/////////////// assignment to output iterator ///////////////////
/////////////////////////////////////////////////////////////////
/**@struct xst_binary_operator_traits< RhsValueT, LhsValueT, operator_id_assignment_2_void >
 * @brief Implements partial template specialization for
 * cttl_impl::operator_id_assignment_2_void assignment operator.
 *
 * @remarks
 * This asignment deals with assignment to dereferenced output iterator:
 @code
        *x = t
 @endcode
 *
 * where @c x is an instance of
 * <a href="http://www.sgi.com/tech/stl/OutputIterator.html">output iterator</a>,
 * and @c t is the output value.
 *
 */
template< typename RhsValueT, typename LhsValueT >
struct xst_binary_operator_traits< RhsValueT, LhsValueT, operator_id_assignment_2_void >
{
    /**Although result is not used, lambda expressions
    * expect non-void return type for any expression.
    */
    typedef int value_type;

}; // struct xst_binary_operator_traits


/////////////////////////////////////////////////////////////////
///////// result types for logical binary operators /////////////
/////////////////////////////////////////////////////////////////
/**@struct xst_binary_operator_traits< RhsValueT, LhsValueT, operator_id_bool >
 * @brief Implements partial template specialization for operators
 * identified by cttl_impl::operator_id_bool constant.
 *
 * @remarks
 * All operators in this category return boolean value as the result.
 *
 */
template< typename RhsValueT, typename LhsValueT >
struct xst_binary_operator_traits< RhsValueT, LhsValueT, operator_id_bool >
{
    typedef bool value_type;

}; // struct xst_binary_operator_traits


/////////////////////////////////////////////////////////////////
/////////// result types for subscript operators ////////////////
/////////////////////////////////////////////////////////////////
/**@struct xst_binary_operator_traits< RhsValueT, LhsValueT, operator_id_subscript >
 * @brief Implements partial template specialization for subscript operators,
 * identified by cttl_impl::operator_id_subscript constant.
 *
 * @remarks
 * Left operand, e.g. STL container, must provide @c value_type typedef,
 * which becomes the result type of lambda expression involving subscript
 * operator.
 *
 */
template< typename RhsValueT, typename LhsValueT >
struct xst_binary_operator_traits< RhsValueT, LhsValueT, operator_id_subscript >
{
    typedef typename LhsValueT::value_type value_type; // LhsValueT is non-scalar

}; // struct xst_binary_operator_traits


//-------------------------------------------------------------------------
// Unary operators traits
//-------------------------------------------------------------------------

// generated by bin\gmu\gmu_lambda\operator_traits.h:685
/////////////////////////////////////////////////////////////////
//////// unspecialized result types unary operators /////////////
/////////////////////////////////////////////////////////////////

/**@struct xst_unary_operator_traits
 * @brief Implements primary template describing traits of C++ unary operator.
 *
 * @tparam ValueT
 *        specifies type X of the operand.
 *
 * @tparam DereferencedValueT
 *        specifies type of the dereferenced object *X, if applicapable.
 *
 * @tparam OperatorIdT
 *        specifies operator id (see above).
 *
 * @remarks
 * When operator policy is compiled, it chooses appropriate
 * result type by selecting either @c ValueT, or @c DereferencedValueT.
 * Compile-time switch, @c xst_unary_operator_traits, allows make choice
 * between @c ValueT and @c DereferencedValueT based on the value of
 * @c OperatorIdT. Naturally, in case of dereference operator,
 * @c DereferencedValueT is chosen, otherwise, @c ValueT.
 *
 * <br/> Logical operators define their result type as bool.
 *
 * <br/> Switch from @c ValueT to @c DereferencedValueT type occurs
 * inside @c top() or @c lvalue_ref() member functions of
 * the dereference operator policy.
 *
 * <br/> When unary policy wrapper class, cttl_impl::xst_unary_adaptor is
 * compiled, a similar compile-time switch between @c ValueT and
 * @c DereferencedValueT is made.
 *
 */
template< typename ValueT,  typename DereferencedValueT, int OperatorIdT >
struct xst_unary_operator_traits
{
    /**Unspecialized version of @c xst_unary_operator_traits leaves @c value_type unchanged.*/
    typedef ValueT value_type;

}; // struct xst_unary_operator_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:729
/////////////////////////////////////////////////////////////////
////////// result types for dereference operators ///////////////
/////////////////////////////////////////////////////////////////

/**@struct xst_unary_operator_traits< ValueT, DereferencedValueT, operator_id_dereference >
 * @brief Implements partial template specialization for dereference operators,
 * identified by cttl_impl::operator_id_dereference constant.
 *
 */
template< typename ValueT,  typename DereferencedValueT >
struct xst_unary_operator_traits< ValueT, DereferencedValueT, operator_id_dereference >
{
    /**Dereference selects user-provided @c DereferencedValueT as the @c value_type.*/
    typedef DereferencedValueT value_type;

}; // struct xst_unary_operator_traits


// generated by bin\gmu\gmu_lambda\operator_traits.h:748
/////////////////////////////////////////////////////////////////
////////// result types for logical not operators ///////////////
/////////////////////////////////////////////////////////////////

/**@struct xst_unary_operator_traits< ValueT, DereferencedValueT, operator_id_bool >
 * @brief Implements partial template specialization for unary logical operators,
 * identified by cttl_impl::operator_id_bool constant.
 *
 */
template< typename ValueT,  typename DereferencedValueT >
struct xst_unary_operator_traits< ValueT, DereferencedValueT, operator_id_bool >
{
    /**In this case @c value_type is boolean.*/
    typedef bool value_type;

}; // struct xst_unary_operator_traits


// generated by bin\gmu\gmu_lambda\operator_traits.h:767
/////////////////////////////////////////////////////////////////
/////////// result type of unary plus for stack /////////////////
/////////////////////////////////////////////////////////////////

/**@struct xst_unary_operator_traits< ValueT, DereferencedValueT, operator_id_stack_unary_plus >
 * @brief Implements partial template specialization for unary plus operator
 * applied to stack primitive, cttl_impl::xst_stack.
 *
 */
template< typename ValueT,  typename DereferencedValueT >
struct xst_unary_operator_traits< ValueT, DereferencedValueT, operator_id_stack_unary_plus >
{
    /**Result of <tt>+stack</tt> expression is the type describing stack size.*/
    typedef typename std::stack< ValueT >::size_type value_type;

}; // struct xst_unary_operator_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:785
/////////////////////////////////////////////////////////////////
//////// result type of postfix decrement for stack /////////////
/////////////////////////////////////////////////////////////////

/**@struct xst_unary_operator_traits< ValueT, DereferencedValueT, operator_id_stack_postfix_decrement >
 * @brief Implements partial template specialization for postfix decrement operator
 * applied to stack primitive, cttl_impl::xst_stack.
 *
 */
template< typename ValueT,  typename DereferencedValueT >
struct xst_unary_operator_traits< ValueT, DereferencedValueT, operator_id_stack_postfix_decrement >
{
    /**Result of <tt>stack--</tt> expression is the type describing stack size.*/
    typedef typename std::stack< ValueT >::size_type value_type;

}; // struct xst_unary_operator_traits

// generated by bin\gmu\gmu_lambda\operator_traits.h:803
/////////////////////////////////////////////////////////////////
//////// result type of prefix decrement for stack /////////////
/////////////////////////////////////////////////////////////////

/**@struct xst_unary_operator_traits< ValueT, DereferencedValueT, operator_id_stack_prefix_decrement >
 * @brief Implements partial template specialization for prefix decrement operator
 * applied to stack primitive, cttl_impl::xst_stack.
 *
 */
template< typename ValueT,  typename DereferencedValueT >
struct xst_unary_operator_traits< ValueT, DereferencedValueT, operator_id_stack_prefix_decrement >
{
    /**Result of <tt>--stack</tt> expression is the type describing stack size.*/
    typedef typename std::stack< ValueT >::size_type value_type;

}; // struct xst_unary_operator_traits


}   // namespace cttl_impl


#endif //_XST_OPERATOR_TRAITS_H_INCLUDED_
