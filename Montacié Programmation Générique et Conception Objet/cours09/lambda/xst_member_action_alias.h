////////////////////////////////////////////////////////////////////////
//
// This file is part of Common Text Transformation Library.
// Copyright (C) 1997-2009 by Igor Kholodov. 
//
// Common Text Transformation Library is free software: you can
// redistribute it and/or modify it under the terms of the
// GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Common Text Transformation Library is distributed in the hope
// that it will be useful, but WITHOUT ANY WARRANTY; without even
// the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
// PURPOSE.  See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with Common Text Transformation Library.
// If not, see <http://www.gnu.org/licenses/>.
//
// mailto:cttl@users.sourceforge.net
// http://cttl.sourceforge.net/
// http://sourceforge.net/projects/cttl/
//
////////////////////////////////////////////////////////////////////////

/**@file xst_member_action_alias.h
 * @brief Defines alias functions.
 *
 * This file was generated by gumus script on Sun Aug 16 21:52:48 2009.
 *
 * @warning
 *      This is internal CTTL header file and should not
 *      be included by user programs.
 *
 */

// xst_member_action_alias.h

#ifndef _XST_MEMBER_ACTION_ALIAS_H_INCLUDED_
#define _XST_MEMBER_ACTION_ALIAS_H_INCLUDED_

namespace cttl {

using namespace cttl_impl;

/**@namespace cttl::alias::associative
 * @brief Alias helpers for
 * @c count() and @c erase()
 * member functions of STL associative containers.
 *
 */
/**@namespace cttl::alias::basic_string
 * @brief Alias helpers for
 * @c std::basic_string::push_back()
 * member function of STL string.
 *
 */
/**@namespace cttl::alias::bitset
 * @brief Alias helpers for
 * member function templates of @c std::bitset.
 *
 */
/**@namespace cttl::alias::edge
 * @brief Alias helpers for
 * member functions of CTTL @c edge classes.
 *
 */
/**@namespace cttl::alias::node
 * @brief Alias helpers for
 * member functions of CTTL @c node class.
 *
 */
/**@namespace cttl::alias::queue
 * @brief Alias helpers for
 * @c front() and @c back()
 * member functions of STL queue container.
 *
 */
/**@namespace cttl::alias
 * @brief Contains prefabricated helper functions to
 * create closures for member functions of CTTL objects and STL containers.
 *
 */
// alias_list.c

namespace alias {

//----------------------------------------------------
// std::stack
//----------------------------------------------------
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:18
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c pop.
*
* Returns closure for
*
@code
    void alias::pop();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
pop(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::pop()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::pop )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:30
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c push.
*
* Returns closure for
*
@code
    void alias::push(value_type const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
push(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::push(value_type const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::push )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:42
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c top.
*
* Returns closure for
*
@code
    X::value_type& alias::top();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::value_type&,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::value_type&
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::value_type&
        >::capacity_,
        LambdaT::primitive_id_
    >
>
top(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::value_type& result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::value_type&,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::value_type&
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::value_type&
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::value_type& alias::top()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::top )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:54
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c top.
*
* Returns closure for
*
@code
    X::value_type const& alias::top()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::value_type const&,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::value_type const&
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::value_type const&
        >::capacity_,
        LambdaT::primitive_id_
    >
>
top(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::value_type const& result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::value_type const&,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::value_type const&
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::value_type const&
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::value_type const& alias::top()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::top )
                )
            )
        ))
        ;
}


//----------------------------------------------------
// std::basic_string
//----------------------------------------------------
namespace basic_string {
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:72
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c push_back.
*
* Returns closure for
*
@code
    void alias::basic_string::push_back(value_type);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
push_back(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although push_back() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::basic_string::push_back(value_type)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::push_back )
                ),
                arg_
            )
        ))
        ;
}

} // namespace basic_string

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:87
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c append.
*
* Returns closure for
*
@code
    X& alias::append(basic_string const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T&,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T&
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T&
        >::capacity_,
        LambdaT::primitive_id_
    >
>
append(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T& result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/typename LambdaT::value_T&,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         typename LambdaT::value_T&
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T&
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X& alias::append(basic_string const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::append )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:99
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c assign.
*
* Returns closure for
*
@code
    X& alias::assign(basic_string const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T&,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T&
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T&
        >::capacity_,
        LambdaT::primitive_id_
    >
>
assign(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T& result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/typename LambdaT::value_T&,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         typename LambdaT::value_T&
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T&
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X& alias::assign(basic_string const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::assign )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:111
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c compare.
*
* Returns closure for
*
@code
    int alias::compare(basic_string const&)const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun1_t<
                                        /*ResultT*/int,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         int
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ int
        >::capacity_,
        LambdaT::primitive_id_
    >
>
compare(
    xst_lambda_wrap< LambdaT > const& lambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef int result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun1_t<
                                            /*ResultT*/int,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         int
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ int
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "int alias::compare(basic_string const&)const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::compare )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:123
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c length.
*
* Returns closure for
*
@code
    X::size_type alias::length()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::size_type,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::size_type
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::size_type
        >::capacity_,
        LambdaT::primitive_id_
    >
>
length(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::size_type result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::size_type,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::size_type
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::size_type
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::size_type alias::length()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::length )
                )
            )
        ))
        ;
}


//----------------------------------------------------
// cttl::node
//----------------------------------------------------
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:139
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c identity.
*
* Returns closure for
*
@code
    int alias::identity(ArgumentT const&)const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun1_t<
                                        /*ResultT*/int,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         int
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ int
        >::capacity_,
        LambdaT::primitive_id_
    >
>
identity(
    xst_lambda_wrap< LambdaT > const& lambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef int result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun1_t<
                                            /*ResultT*/int,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         int
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ int
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "int alias::identity(ArgumentT const&)const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::identity )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:151
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c offset.
*
* Returns closure for
*
@code
    size_t alias::offset()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
offset(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::offset()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::offset )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:163
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c offset.
*
* Returns closure for
*
@code
    size_t alias::offset(size_t);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
offset(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although offset() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::offset(size_t)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::offset )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:175
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c line.
*
* Returns closure for
*
@code
    size_t alias::line()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
line(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::line()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::line )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:187
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c go_line.
*
* Returns closure for
*
@code
    size_t alias::go_line(size_t);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
go_line(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although go_line() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::go_line(size_t)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::go_line )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:199
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c go_bof.
*
* Returns closure for
*
@code
    size_t alias::go_bof();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
go_bof(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::go_bof()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::go_bof )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:211
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c go_eof.
*
* Returns closure for
*
@code
    size_t alias::go_eof();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
go_eof(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::go_eof()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::go_eof )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:223
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c go_line_next.
*
* Returns closure for
*
@code
    size_t alias::go_line_next();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
go_line_next(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::go_line_next()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::go_line_next )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:235
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c go_line_previous.
*
* Returns closure for
*
@code
    size_t alias::go_line_previous();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
go_line_previous(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::go_line_previous()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::go_line_previous )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:247
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c go_line_home.
*
* Returns closure for
*
@code
    size_t alias::go_line_home();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
go_line_home(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::go_line_home()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::go_line_home )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:259
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c go_line_home.
*
* Returns closure for
*
@code
    size_t alias::go_line_home(size_t);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
go_line_home(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although go_line_home() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::go_line_home(size_t)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::go_line_home )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:271
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c go_line_end.
*
* Returns closure for
*
@code
    size_t alias::go_line_end();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
go_line_end(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::go_line_end()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::go_line_end )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:283
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c go_line_end.
*
* Returns closure for
*
@code
    size_t alias::go_line_end(size_t);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
go_line_end(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although go_line_end() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::go_line_end(size_t)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::go_line_end )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:295
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c insert_go.
*
* Returns closure for
*
@code
    size_t alias::insert_go(StringT const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
insert_go(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::insert_go(StringT const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::insert_go )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:307
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c insert_stay.
*
* Returns closure for
*
@code
    void alias::insert_stay(StringT const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
insert_stay(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::insert_stay(StringT const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::insert_stay )
                ),
                arg_
            )
        ))
        ;
}


//----------------------------------------------------
// cttl::const_edge
// cttl::edge
//----------------------------------------------------
namespace edge {
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:326
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c insert_go.
*
* Returns closure for
*
@code
    void alias::edge::insert_go(ArgumentT&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT&
                                    >,
                /*ArgumentT*/       ArgumentT&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
insert_go(
    xst_lambda_wrap< LambdaT >* plambda_,
    // mutable argument is passed to pointer:
    ArgumentT* parg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT&
                                        >,
                    /*ArgumentT*/       ArgumentT&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::edge::insert_go(ArgumentT&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT&
                    >
                    ( &object_T::insert_go )
                ),
                // if argument is mutable, it is passed to the
                // member function policy by mutable address:
                parg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:338
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c insert_stay.
*
* Returns closure for
*
@code
    void alias::edge::insert_stay(ArgumentT&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT&
                                    >,
                /*ArgumentT*/       ArgumentT&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
insert_stay(
    xst_lambda_wrap< LambdaT >* plambda_,
    // mutable argument is passed to pointer:
    ArgumentT* parg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT&
                                        >,
                    /*ArgumentT*/       ArgumentT&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::edge::insert_stay(ArgumentT&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT&
                    >
                    ( &object_T::insert_stay )
                ),
                // if argument is mutable, it is passed to the
                // member function policy by mutable address:
                parg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:350
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c text.
*
* Returns closure for
*
@code
    void alias::edge::text(ArgumentT const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
text(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::edge::text(ArgumentT const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::text )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:362
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c erase.
*
* Returns closure for
*
@code
    void alias::edge::erase();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
erase(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::edge::erase()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::erase )
                )
            )
        ))
        ;
}

} // namespace edge

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:377
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c text.
*
* Returns closure for
*
@code
    X::string_T alias::text()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::string_T,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::string_T
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::string_T
        >::capacity_,
        LambdaT::primitive_id_
    >
>
text(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::string_T result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::string_T,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::string_T
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::string_T
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::string_T alias::text()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::text )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:389
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c text_tolower.
*
* Returns closure for
*
@code
    void alias::text_tolower();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
text_tolower(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::text_tolower()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::text_tolower )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:401
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c text_toupper.
*
* Returns closure for
*
@code
    void alias::text_toupper();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
text_toupper(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::text_toupper()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::text_toupper )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:413
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c text.
*
* Returns closure for
*
@code
    void alias::text(StringT const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
text(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::text(StringT const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::text )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:425
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c text_swap.
*
* Returns closure for
*
@code
    void alias::text_swap(ArgumentT&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT&
                                    >,
                /*ArgumentT*/       ArgumentT&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
text_swap(
    xst_lambda_wrap< LambdaT >* plambda_,
    // mutable argument is passed to pointer:
    ArgumentT* parg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT&
                                        >,
                    /*ArgumentT*/       ArgumentT&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::text_swap(ArgumentT&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT&
                    >
                    ( &object_T::text_swap )
                ),
                // if argument is mutable, it is passed to the
                // member function policy by mutable address:
                parg_
            )
        ))
        ;
}


//----------------------------------------------------
// std::set
//----------------------------------------------------
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:441
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:30
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_arg.h:1

/**Alias helper function @c find.
*
* Returns closure (translator) for
*
@code
    X::const_iterator alias::find(key_type const&)const;
@endcode
*
* member function. Translator delays actual function
* call till run-time by capturing pointer to member function,
* function argument, and a copy of return value.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::const_iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::const_iterator,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::const_iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
find(
    xst_lambda_wrap< LambdaT > const& lambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::const_iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::const_iterator alias::find(key_type const&)const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::find )
                ),
                arg_
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:453
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:30
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_arg.h:1

/**Alias helper function @c lower_bound.
*
* Returns closure (translator) for
*
@code
    X::const_iterator alias::lower_bound(key_type const&)const;
@endcode
*
* member function. Translator delays actual function
* call till run-time by capturing pointer to member function,
* function argument, and a copy of return value.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::const_iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::const_iterator,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::const_iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
lower_bound(
    xst_lambda_wrap< LambdaT > const& lambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::const_iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::const_iterator alias::lower_bound(key_type const&)const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::lower_bound )
                ),
                arg_
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:465
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:30
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_arg.h:1

/**Alias helper function @c upper_bound.
*
* Returns closure (translator) for
*
@code
    X::const_iterator alias::upper_bound(key_type const &)const;
@endcode
*
* member function. Translator delays actual function
* call till run-time by capturing pointer to member function,
* function argument, and a copy of return value.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::const_iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::const_iterator,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const &
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::const_iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
upper_bound(
    xst_lambda_wrap< LambdaT > const& lambda_,
    ArgumentT const & arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::const_iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::const_iterator alias::upper_bound(key_type const &)const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const &
                    >
                    ( &object_T::upper_bound )
                ),
                arg_
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:477
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c equal_range.
*
* Returns closure for
*
@code
    std::pair< typename LambdaT::value_T::const_iterator, typename LambdaT::value_T::const_iterator > alias::equal_range(key_type const&)const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun1_t<
                                        /*ResultT*/std::pair< typename LambdaT::value_T::const_iterator, typename LambdaT::value_T::const_iterator >,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         std::pair< typename LambdaT::value_T::const_iterator, typename LambdaT::value_T::const_iterator >
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ std::pair< typename LambdaT::value_T::const_iterator, typename LambdaT::value_T::const_iterator >
        >::capacity_,
        LambdaT::primitive_id_
    >
>
equal_range(
    xst_lambda_wrap< LambdaT > const& lambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef std::pair< typename LambdaT::value_T::const_iterator, typename LambdaT::value_T::const_iterator > result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun1_t<
                                            /*ResultT*/std::pair< typename LambdaT::value_T::const_iterator, typename LambdaT::value_T::const_iterator >,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         std::pair< typename LambdaT::value_T::const_iterator, typename LambdaT::value_T::const_iterator >
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ std::pair< typename LambdaT::value_T::const_iterator, typename LambdaT::value_T::const_iterator >
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "std::pair< typename LambdaT::value_T::const_iterator, typename LambdaT::value_T::const_iterator > alias::equal_range(key_type const&)const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::equal_range )
                ),
                arg_
            )
        ))
        ;
}


//----------------------------------------------------
// STL sequence
//----------------------------------------------------
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:493
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c at.
*
* Returns closure for
*
@code
    X::const_reference alias::at(size_type)const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::const_reference,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::const_reference
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::const_reference
        >::capacity_,
        LambdaT::primitive_id_
    >
>
at(
    xst_lambda_wrap< LambdaT > const& lambda_,
    // Although at() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::const_reference result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun1_t<
                                            /*ResultT*/typename LambdaT::value_T::const_reference,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         typename LambdaT::value_T::const_reference
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::const_reference
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::const_reference alias::at(size_type)const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::at )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:505
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c back.
*
* Returns closure for
*
@code
    X::const_reference alias::back()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::const_reference,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::const_reference
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::const_reference
        >::capacity_,
        LambdaT::primitive_id_
    >
>
back(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::const_reference result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::const_reference,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::const_reference
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::const_reference
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::const_reference alias::back()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::back )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:517
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:22
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_noarg.h:1

/**Alias helper function @c begin.
*
* Returns closure (translator) for
*
@code
    X::const_iterator alias::begin()const;
@endcode
*
* member function. Translator delays actual function
* call by capturing pointer to member function and
* a copy of return value.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::const_iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::const_iterator,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::const_iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
begin(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::const_iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::const_iterator alias::begin()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::begin )
                )
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:529
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:22
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_noarg.h:1

/**Alias helper function @c end.
*
* Returns closure (translator) for
*
@code
    X::const_iterator alias::end()const;
@endcode
*
* member function. Translator delays actual function
* call by capturing pointer to member function and
* a copy of return value.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::const_iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::const_iterator,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::const_iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
end(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::const_iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::const_iterator alias::end()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::end )
                )
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:541
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c front.
*
* Returns closure for
*
@code
    X::const_reference alias::front()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::const_reference,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::const_reference
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::const_reference
        >::capacity_,
        LambdaT::primitive_id_
    >
>
front(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::const_reference result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::const_reference,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::const_reference
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::const_reference
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::const_reference alias::front()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::front )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:553
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:22
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_noarg.h:1

/**Alias helper function @c rbegin.
*
* Returns closure (translator) for
*
@code
    X::const_reverse_iterator alias::rbegin()const;
@endcode
*
* member function. Translator delays actual function
* call by capturing pointer to member function and
* a copy of return value.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::const_reverse_iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::const_reverse_iterator,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::const_reverse_iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
rbegin(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::const_reverse_iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::const_reverse_iterator alias::rbegin()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::rbegin )
                )
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:565
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:22
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_noarg.h:1

/**Alias helper function @c rend.
*
* Returns closure (translator) for
*
@code
    X::const_reverse_iterator alias::rend()const;
@endcode
*
* member function. Translator delays actual function
* call by capturing pointer to member function and
* a copy of return value.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::const_reverse_iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::const_reverse_iterator,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::const_reverse_iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
rend(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::const_reverse_iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::const_reverse_iterator alias::rend()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::rend )
                )
            )//action
        )//make_translator
        ;
}


// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:578
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c at.
*
* Returns closure for
*
@code
    X::reference alias::at(size_type);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::reference,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::reference
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::reference
        >::capacity_,
        LambdaT::primitive_id_
    >
>
at(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although at() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::reference result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/typename LambdaT::value_T::reference,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         typename LambdaT::value_T::reference
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::reference
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::reference alias::at(size_type)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::at )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:590
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c back.
*
* Returns closure for
*
@code
    X::reference alias::back();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::reference,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::reference
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::reference
        >::capacity_,
        LambdaT::primitive_id_
    >
>
back(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::reference result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::reference,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::reference
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::reference
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::reference alias::back()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::back )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:602
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:22
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_noarg.h:1

/**Alias helper function @c begin.
*
* Returns closure (translator) for
*
@code
    X::iterator alias::begin();
@endcode
*
* member function. Translator delays actual function
* call by capturing pointer to member function and
* a copy of return value.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::iterator,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
begin(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::iterator alias::begin()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::begin )
                )
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:614
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c capacity.
*
* Returns closure for
*
@code
    X::size_type alias::capacity()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::size_type,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::size_type
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::size_type
        >::capacity_,
        LambdaT::primitive_id_
    >
>
capacity(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::size_type result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::size_type,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::size_type
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::size_type
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::size_type alias::capacity()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::capacity )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:626
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c clear.
*
* Returns closure for
*
@code
    void alias::clear();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
clear(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::clear()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::clear )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:638
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c empty.
*
* Returns closure for
*
@code
    bool alias::empty()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/bool,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         bool
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ bool
        >::capacity_,
        LambdaT::primitive_id_
    >
>
empty(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef bool result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/bool,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         bool
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ bool
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "bool alias::empty()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::empty )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:650
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:22
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_noarg.h:1

/**Alias helper function @c end.
*
* Returns closure (translator) for
*
@code
    X::iterator alias::end();
@endcode
*
* member function. Translator delays actual function
* call by capturing pointer to member function and
* a copy of return value.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::iterator,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
end(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::iterator alias::end()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::end )
                )
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:662
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:30
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_arg.h:1

/**Alias helper function @c erase.
*
* Returns closure (translator) for
*
@code
    X::iterator alias::erase(iterator);
@endcode
*
* member function. Translator delays actual function
* call till run-time by capturing pointer to member function,
* function argument, and a copy of return value.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::iterator,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
erase(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although erase() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::iterator alias::erase(iterator)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::erase )
                ),
                arg_
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:674
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c front.
*
* Returns closure for
*
@code
    X::reference alias::front();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::reference,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::reference
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::reference
        >::capacity_,
        LambdaT::primitive_id_
    >
>
front(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::reference result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::reference,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::reference
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::reference
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::reference alias::front()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::front )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:686
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c max_size.
*
* Returns closure for
*
@code
    X::size_type alias::max_size()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::size_type,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::size_type
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::size_type
        >::capacity_,
        LambdaT::primitive_id_
    >
>
max_size(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::size_type result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::size_type,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::size_type
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::size_type
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::size_type alias::max_size()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::max_size )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:698
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c pop_back.
*
* Returns closure for
*
@code
    void alias::pop_back();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
pop_back(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::pop_back()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::pop_back )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:710
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c push_back.
*
* Returns closure for
*
@code
    void alias::push_back(value_type const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
push_back(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::push_back(value_type const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::push_back )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:722
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:22
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_noarg.h:1

/**Alias helper function @c rbegin.
*
* Returns closure (translator) for
*
@code
    X::reverse_iterator alias::rbegin();
@endcode
*
* member function. Translator delays actual function
* call by capturing pointer to member function and
* a copy of return value.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::reverse_iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::reverse_iterator,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::reverse_iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
rbegin(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::reverse_iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::reverse_iterator alias::rbegin()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::rbegin )
                )
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:734
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:22
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_noarg.h:1

/**Alias helper function @c rend.
*
* Returns closure (translator) for
*
@code
    X::reverse_iterator alias::rend();
@endcode
*
* member function. Translator delays actual function
* call by capturing pointer to member function and
* a copy of return value.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::reverse_iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::reverse_iterator,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::reverse_iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
rend(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::reverse_iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::reverse_iterator alias::rend()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::rend )
                )
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:746
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c resize.
*
* Returns closure for
*
@code
    void alias::resize(size_type);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
resize(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although resize() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::resize(size_type)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::resize )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:758
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c reserve.
*
* Returns closure for
*
@code
    void alias::reserve(size_type);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
reserve(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although reserve() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::reserve(size_type)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::reserve )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:770
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c size.
*
* Returns closure for
*
@code
    X::size_type alias::size()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::size_type,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::size_type
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::size_type
        >::capacity_,
        LambdaT::primitive_id_
    >
>
size(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::size_type result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::size_type,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::size_type
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::size_type
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::size_type alias::size()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::size )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:782
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c swap.
*
* Returns closure for
*
@code
    void alias::swap(vector&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT&
                                    >,
                /*ArgumentT*/       ArgumentT&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
swap(
    xst_lambda_wrap< LambdaT >* plambda_,
    // mutable argument is passed to pointer:
    ArgumentT* parg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT&
                                        >,
                    /*ArgumentT*/       ArgumentT&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::swap(vector&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT&
                    >
                    ( &object_T::swap )
                ),
                // if argument is mutable, it is passed to the
                // member function policy by mutable address:
                parg_
            )
        ))
        ;
}


//----------------------------------------------------
// std::queue
//----------------------------------------------------
namespace queue {
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:800
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c back.
*
* Returns closure for
*
@code
    X::value_type const& alias::queue::back()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::value_type const&,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::value_type const&
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::value_type const&
        >::capacity_,
        LambdaT::primitive_id_
    >
>
back(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::value_type const& result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::value_type const&,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::value_type const&
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::value_type const&
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::value_type const& alias::queue::back()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::back )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:812
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c back.
*
* Returns closure for
*
@code
    X::value_type& alias::queue::back();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::value_type&,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::value_type&
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::value_type&
        >::capacity_,
        LambdaT::primitive_id_
    >
>
back(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::value_type& result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::value_type&,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::value_type&
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::value_type&
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::value_type& alias::queue::back()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::back )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:824
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c front.
*
* Returns closure for
*
@code
    X::value_type const& alias::queue::front()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::value_type const&,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::value_type const&
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::value_type const&
        >::capacity_,
        LambdaT::primitive_id_
    >
>
front(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::value_type const& result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::value_type const&,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::value_type const&
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::value_type const&
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::value_type const& alias::queue::front()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::front )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:836
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c front.
*
* Returns closure for
*
@code
    X::value_type& alias::queue::front();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/typename LambdaT::value_T::value_type&,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         typename LambdaT::value_T::value_type&
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::value_type&
        >::capacity_,
        LambdaT::primitive_id_
    >
>
front(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::value_type& result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/typename LambdaT::value_T::value_type&,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         typename LambdaT::value_T::value_type&
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::value_type&
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::value_type& alias::queue::front()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::front )
                )
            )
        ))
        ;
}

} //namespace queue

//----------------------------------------------------
// std::deque
//----------------------------------------------------
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:854
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c pop_front.
*
* Returns closure for
*
@code
    void alias::pop_front();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
pop_front(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::pop_front()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::pop_front )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:866
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c push_front.
*
* Returns closure for
*
@code
    void alias::push_front(value_type const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
push_front(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::push_front(value_type const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::push_front )
                ),
                arg_
            )
        ))
        ;
}


//----------------------------------------------------
// std::list
//----------------------------------------------------
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:882
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c remove.
*
* Returns closure for
*
@code
    void alias::remove(value_type const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
remove(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::remove(value_type const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::remove )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:894
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c reverse.
*
* Returns closure for
*
@code
    void alias::reverse();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
reverse(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::reverse()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::reverse )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:906
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c sort.
*
* Returns closure for
*
@code
    void alias::sort();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
sort(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::sort()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::sort )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:918
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c unique.
*
* Returns closure for
*
@code
    void alias::unique();
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
unique(
    xst_lambda_wrap< LambdaT >* plambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::unique()",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::unique )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:930
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c merge.
*
* Returns closure for
*
@code
    void alias::merge(list&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/void,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT&
                                    >,
                /*ArgumentT*/       ArgumentT&,
                /*ResultT*/         void
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ void
        >::capacity_,
        LambdaT::primitive_id_
    >
>
merge(
    xst_lambda_wrap< LambdaT >* plambda_,
    // mutable argument is passed to pointer:
    ArgumentT* parg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef void result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/void,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT&
                                        >,
                    /*ArgumentT*/       ArgumentT&,
                    /*ResultT*/         void
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ void
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "void alias::merge(list&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT&
                    >
                    ( &object_T::merge )
                ),
                // if argument is mutable, it is passed to the
                // member function policy by mutable address:
                parg_
            )
        ))
        ;
}


//----------------------------------------------------
// STL associative container
//----------------------------------------------------
namespace associative {
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:948
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c count.
*
* Returns closure for
*
@code
    X::size_type alias::associative::count(key_type const&)const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::size_type,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::size_type
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::size_type
        >::capacity_,
        LambdaT::primitive_id_
    >
>
count(
    xst_lambda_wrap< LambdaT > const& lambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::size_type result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun1_t<
                                            /*ResultT*/typename LambdaT::value_T::size_type,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         typename LambdaT::value_T::size_type
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::size_type
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::size_type alias::associative::count(key_type const&)const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::count )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:960
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c erase.
*
* Returns closure for
*
@code
    X::size_type alias::associative::erase(key_type const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::size_type,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::size_type
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ typename LambdaT::value_T::size_type
        >::capacity_,
        LambdaT::primitive_id_
    >
>
erase(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::size_type result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/typename LambdaT::value_T::size_type,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         typename LambdaT::value_T::size_type
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ typename LambdaT::value_T::size_type
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::size_type alias::associative::erase(key_type const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::erase )
                ),
                arg_
            )
        ))
        ;
}

} // namespace associative

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:975
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:30
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_arg.h:1

/**Alias helper function @c find.
*
* Returns closure (translator) for
*
@code
    X::iterator alias::find(key_type const&);
@endcode
*
* member function. Translator delays actual function
* call till run-time by capturing pointer to member function,
* function argument, and a copy of return value.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::iterator,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
find(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::iterator alias::find(key_type const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::find )
                ),
                arg_
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:987
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:30
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_arg.h:1

/**Alias helper function @c lower_bound.
*
* Returns closure (translator) for
*
@code
    X::iterator alias::lower_bound(key_type const&);
@endcode
*
* member function. Translator delays actual function
* call till run-time by capturing pointer to member function,
* function argument, and a copy of return value.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::iterator,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
lower_bound(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::iterator alias::lower_bound(key_type const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::lower_bound )
                ),
                arg_
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:999
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:30
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_arg.h:1

/**Alias helper function @c upper_bound.
*
* Returns closure (translator) for
*
@code
    X::iterator alias::upper_bound(key_type const&);
@endcode
*
* member function. Translator delays actual function
* call till run-time by capturing pointer to member function,
* function argument, and a copy of return value.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::iterator,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
upper_bound(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::iterator alias::upper_bound(key_type const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::upper_bound )
                ),
                arg_
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:1011
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c insert.
*
* Returns closure for
*
@code
    std::pair< typename LambdaT::value_T::iterator, bool > alias::insert(value_type const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/std::pair< typename LambdaT::value_T::iterator, bool >,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         std::pair< typename LambdaT::value_T::iterator, bool >
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ std::pair< typename LambdaT::value_T::iterator, bool >
        >::capacity_,
        LambdaT::primitive_id_
    >
>
insert(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef std::pair< typename LambdaT::value_T::iterator, bool > result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/std::pair< typename LambdaT::value_T::iterator, bool >,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         std::pair< typename LambdaT::value_T::iterator, bool >
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ std::pair< typename LambdaT::value_T::iterator, bool >
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "std::pair< typename LambdaT::value_T::iterator, bool > alias::insert(value_type const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::insert )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:1023
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c equal_range.
*
* Returns closure for
*
@code
    std::pair< typename LambdaT::value_T::iterator, typename LambdaT::value_T::iterator > alias::equal_range(key_type const&);
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/std::pair< typename LambdaT::value_T::iterator, typename LambdaT::value_T::iterator >,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT const&
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         std::pair< typename LambdaT::value_T::iterator, typename LambdaT::value_T::iterator >
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ std::pair< typename LambdaT::value_T::iterator, typename LambdaT::value_T::iterator >
        >::capacity_,
        LambdaT::primitive_id_
    >
>
equal_range(
    xst_lambda_wrap< LambdaT >* plambda_,
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef std::pair< typename LambdaT::value_T::iterator, typename LambdaT::value_T::iterator > result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T &,
                    /*MemberActionT*/   std::mem_fun1_t<
                                            /*ResultT*/std::pair< typename LambdaT::value_T::iterator, typename LambdaT::value_T::iterator >,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT const&
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         std::pair< typename LambdaT::value_T::iterator, typename LambdaT::value_T::iterator >
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ std::pair< typename LambdaT::value_T::iterator, typename LambdaT::value_T::iterator >
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "std::pair< typename LambdaT::value_T::iterator, typename LambdaT::value_T::iterator > alias::equal_range(key_type const&)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT const&
                    >
                    ( &object_T::equal_range )
                ),
                arg_
            )
        ))
        ;
}


//----------------------------------------------------
// slist (http://www.sgi.com/tech/stl/Slist.html)
//----------------------------------------------------
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:1039
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:30
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_arg.h:1

/**Alias helper function @c previous.
*
* Returns closure (translator) for
*
@code
    X::const_iterator alias::previous(const_iterator);
@endcode
*
* member function. Translator delays actual function
* call till run-time by capturing pointer to member function,
* function argument, and a copy of return value.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::const_iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::const_iterator,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::const_iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
previous(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although previous() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::const_iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::const_iterator alias::previous(const_iterator)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::previous )
                ),
                arg_
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:1051
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:30
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_arg.h:1

/**Alias helper function @c previous.
*
* Returns closure (translator) for
*
@code
    X::iterator alias::previous(iterator);
@endcode
*
* member function. Translator delays actual function
* call till run-time by capturing pointer to member function,
* function argument, and a copy of return value.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::iterator,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
previous(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although previous() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::iterator alias::previous(iterator)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::previous )
                ),
                arg_
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:1063
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:30
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_arg.h:1

/**Alias helper function @c insert_after.
*
* Returns closure (translator) for
*
@code
    X::iterator alias::insert_after(iterator);
@endcode
*
* member function. Translator delays actual function
* call till run-time by capturing pointer to member function,
* function argument, and a copy of return value.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::iterator,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
insert_after(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although insert_after() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::iterator alias::insert_after(iterator)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::insert_after )
                ),
                arg_
            )//action
        )//make_translator
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:1075
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:30
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\translate_mf_arg.h:1

/**Alias helper function @c erase_after.
*
* Returns closure (translator) for
*
@code
    X::iterator alias::erase_after(iterator);
@endcode
*
* member function. Translator delays actual function
* call till run-time by capturing pointer to member function,
* function argument, and a copy of return value.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_translator<
            xst_scalar< /*ResultT*/typename LambdaT::value_T::iterator >
            ,
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T &,
                /*MemberActionT*/   std::mem_fun1_t<
                                        /*ResultT*/typename LambdaT::value_T::iterator,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         typename LambdaT::value_T::iterator
            >
        >
    >
    ,
    xst_prefix_increment_policy<
        /*capacity_*/1,
        primitive_id_translator
    >
>
erase_after(
    xst_lambda_wrap< LambdaT >* plambda_,
    // Although erase_after() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef typename LambdaT::value_T::iterator result_T;
    
    return
        ++make_translator(            
            scalar( result_T() )
            ,
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "X::iterator alias::erase_after(iterator)",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                &plambda_->top( const_scalar( 0 ) ),
                ( std::mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::erase_after )
                ),
                arg_
            )//action
        )//make_translator
        ;
}


//----------------------------------------------------
// std::bitset
//----------------------------------------------------
namespace bitset {
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:1093
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c size.
*
* Returns closure for
*
@code
    size_t alias::bitset::size()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
size(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::bitset::size()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::size )
                )
            )
        ))
        ;
}

} // namespace bitset

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:1108
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c any.
*
* Returns closure for
*
@code
    bool alias::any()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/bool,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         bool
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ bool
        >::capacity_,
        LambdaT::primitive_id_
    >
>
any(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef bool result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/bool,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         bool
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ bool
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "bool alias::any()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::any )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:1120
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c count.
*
* Returns closure for
*
@code
    size_t alias::count()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/size_t,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         size_t
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ size_t
        >::capacity_,
        LambdaT::primitive_id_
    >
>
count(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef size_t result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/size_t,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         size_t
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ size_t
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "size_t alias::count()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::count )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:1132
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c none.
*
* Returns closure for
*
@code
    bool alias::none()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/bool,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         bool
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ bool
        >::capacity_,
        LambdaT::primitive_id_
    >
>
none(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef bool result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/bool,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         bool
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ bool
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "bool alias::none()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::none )
                )
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:1144
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:33
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_arg.h:1

/**Alias helper function @c test.
*
* Returns closure for
*
@code
    bool alias::test(size_t)const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function
* and its argument.
*
*/
template< typename LambdaT, typename ArgumentT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun1_t<
                                        /*ResultT*/bool,
                                        /*ObjectT*/typename LambdaT::value_T,
                                        /*ArgumentT*/ArgumentT
                                    >,
                /*ArgumentT*/       ArgumentT const&,
                /*ResultT*/         bool
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ bool
        >::capacity_,
        LambdaT::primitive_id_
    >
>
test(
    xst_lambda_wrap< LambdaT > const& lambda_,
    // Although test() receives its argument by value,
    // this helper passes it by const reference.
    ArgumentT const& arg_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef bool result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun1_t<
                                            /*ResultT*/bool,
                                            /*ObjectT*/typename LambdaT::value_T,
                                            /*ArgumentT*/ArgumentT
                                        >,
                    /*ArgumentT*/       ArgumentT const&,
                    /*ResultT*/         bool
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ bool
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "bool alias::test(size_t)const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun1_t<
                    result_T,
                    object_T,
                    ArgumentT
                    >
                    ( &object_T::test )
                ),
                arg_
            )
        ))
        ;
}

// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\alias_list.h:1156
// generated by bin/gmu/gmu_lambda/gmu_action_aliases/headers/action_aliases.h:25
// generated by bin\gmu\gmu_lambda\gmu_action_aliases\headers\deref_mf_noarg.h:1

/**Alias helper function @c to_ulong.
*
* Returns closure for
*
@code
    unsigned long alias::to_ulong()const;
@endcode
*
* member function. The closure object delays actual function
* call till run-time by capturing pointer to member function.
*
*/
template< typename LambdaT >
inline
xst_unary_adaptor<
    xst_lambda_wrap<
        xst_scalar<
            xst_member_action<
                /*ObjectT*/         typename LambdaT::value_T const&,
                /*MemberActionT*/   std::const_mem_fun_t<
                                        /*ResultT*/unsigned long,
                                        /*ObjectT*/typename LambdaT::value_T
                                    >,
                /*ArgumentT*/       void,
                /*ResultT*/         unsigned long
            >
        >
    >
    ,
    xst_dereference_policy<
        xst_dereference_traits<
            /*ObjectT*/ typename LambdaT::value_T,
            /*ResultT*/ unsigned long
        >::capacity_,
        LambdaT::primitive_id_
    >
>
to_ulong(
    xst_lambda_wrap< LambdaT > const& lambda_
    )
{
    typedef typename LambdaT::value_T object_T;
    typedef unsigned long result_T;
    typedef xst_unary_adaptor<
        xst_lambda_wrap<
            xst_scalar<
                xst_member_action<
                    /*ObjectT*/         typename LambdaT::value_T const&,
                    /*MemberActionT*/   std::const_mem_fun_t<
                                            /*ResultT*/unsigned long,
                                            /*ObjectT*/typename LambdaT::value_T
                                        >,
                    /*ArgumentT*/       void,
                    /*ResultT*/         unsigned long
                >
            >
        >
        ,
        xst_dereference_policy<
            xst_dereference_traits<
                /*ObjectT*/ typename LambdaT::value_T,
                /*ResultT*/ unsigned long
            >::capacity_,
            LambdaT::primitive_id_
        >
    >
    xst_adaptor_T;

    return xst_adaptor_T( scalar(
#ifdef CTTL_TRACE_DEPOSITS
            xst_traced_action(
                __LINE__,
                "unsigned long alias::to_ulong()const",
#else
            action(
#endif // CTTL_TRACE_DEPOSITS
                lambda_.top( const_scalar( 0 ) ),
                ( std::const_mem_fun_t<
                    result_T,
                    object_T
                    >
                    ( &object_T::to_ulong )
                )
            )
        ))
        ;
}


} // namespace alias

}   // namespace cttl


#endif //_XST_MEMBER_ACTION_ALIAS_H_INCLUDED_
