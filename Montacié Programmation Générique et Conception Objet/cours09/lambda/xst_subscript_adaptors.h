////////////////////////////////////////////////////////////////////////
//
// This file is part of Common Text Transformation Library.
// Copyright (C) 1997-2009 by Igor Kholodov. 
//
// Common Text Transformation Library is free software: you can
// redistribute it and/or modify it under the terms of the
// GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Common Text Transformation Library is distributed in the hope
// that it will be useful, but WITHOUT ANY WARRANTY; without even
// the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
// PURPOSE.  See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with Common Text Transformation Library.
// If not, see <http://www.gnu.org/licenses/>.
//
// mailto:cttl@users.sourceforge.net
// http://cttl.sourceforge.net/
// http://sourceforge.net/projects/cttl/
//
////////////////////////////////////////////////////////////////////////

/**@file xst_subscript_adaptors.h
 * @brief Defines lambda subscript operator policy classes.
 *
 * This file was generated by gumus script on Sun Aug 16 21:52:47 2009.
 *
 * @warning
 *      This is internal CTTL header file and should not
 *      be included by user programs.
 *
 */

// xst_subscript_adaptors.h

#ifndef _XST_SUBSCRIPT_ADAPTORS_H_INCLUDED_
#define _XST_SUBSCRIPT_ADAPTORS_H_INCLUDED_

namespace cttl_impl {

// generated by bin/gmu/gmu_lambda/gmu_common.h:919
// generated by bin/gmu/gmu_lambda/gmu_common.h:114
// generated by bin\gmu\gmu_lambda\operators/subscript/subscript_adaptor_struct.h:1

// X[ R ] -> A<R_,X_,id>, where A := xst_subscript_policy< RhsCapacityT, LhsCapacityT, PrimitiveIdT >

/**@struct xst_subscript_policy
 * @brief General purpose binary array access [] operator runtime policy.
 *
 @code
    X[ R ]
 @endcode
 * where X and R are lambda primitives, X overloads array
 * operator, and R is an rvalue representing subscript.
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the left-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_subscript_policy {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_subscript;

    /**Implementation of subscript array operator for
    *  CTTL lambda primitive.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of expression <tt>X[ R ]</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::dereferenced_value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "[ " );
        typename LambdaRhsT::value_T rhs_value( rhs_lambda_.top( const_scalar( 0 ) ) );
        CTTL_TRACE_DEPOSIT_TEXT( ']' );
        return lhs_lambda_.top( const_scalar( 0 ) )[ rhs_value ];
    }

    /**Lvalue support: result of subscript access to X is an lvalue.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        lambda primitive with subscript access.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        Mutable reference to the encapsulated value.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename LambdaLhsT::dereferenced_value_T&
    lvalue_ref(
               LambdaLhsT& lhs_lambda_,
               LambdaRhsT const& rhs_lambda_
               )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "-> [ " );
        typename LambdaRhsT::value_T rhs_value( rhs_lambda_.top( const_scalar( 0 ) ) );
        CTTL_TRACE_DEPOSIT_TEXT( ']' );
        return lhs_lambda_.top( const_scalar( 0 ) )[ rhs_value ];
    }

    /**Lambda expresion <tt>X[ R ]</tt> has no side effects.*/
    template< typename LambdaLhsT, typename LambdaRhsT >
    static void prefix_side_effects(
        LambdaLhsT&,
        LambdaRhsT const&
        )
    {
    }

    /**Lambda expresion <tt>X[ R ]</tt> has no side effects.*/
    template< typename LambdaLhsT >
    static void postfix_side_effects( LambdaLhsT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X[ R ]</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X[ R ]</tt> succeeds if integral result of lambda
    *    expression <tt>X[ R ]</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_subscript_policy

}   // namespace cttl_impl


#endif //_XST_SUBSCRIPT_ADAPTORS_H_INCLUDED_
