////////////////////////////////////////////////////////////////////////
//
// This file is part of Common Text Transformation Library.
// Copyright (C) 1997-2009 by Igor Kholodov. 
//
// Common Text Transformation Library is free software: you can
// redistribute it and/or modify it under the terms of the
// GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Common Text Transformation Library is distributed in the hope
// that it will be useful, but WITHOUT ANY WARRANTY; without even
// the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
// PURPOSE.  See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with Common Text Transformation Library.
// If not, see <http://www.gnu.org/licenses/>.
//
// mailto:cttl@users.sourceforge.net
// http://cttl.sourceforge.net/
// http://sourceforge.net/projects/cttl/
//
////////////////////////////////////////////////////////////////////////

/**@file xst_operator_adaptors.h
 * @brief Defines lambda operator policy classes.
 *
 * This file was generated by gumus script on Sun Aug 16 21:52:47 2009.
 *
 * @warning
 *      This is internal CTTL header file and should not
 *      be included by user programs.
 *
 */

// xst_operator_adaptors.h

#ifndef _XST_OPERATOR_ADAPTORS_H_INCLUDED_
#define _XST_OPERATOR_ADAPTORS_H_INCLUDED_

namespace cttl_impl {

// generated by bin/gmu/gmu_lambda/gmu_common.h:331
// generated by bin/gmu/gmu_lambda/gmu_common.h:17
// generated by bin\gmu\gmu_lambda\operators/dereference/gp_dereference_adaptor.h:1

// *X -> A<X_,id>, where A := xst_dereference_policy< CapacityT, PrimitiveIdT >

/**@struct xst_dereference_policy
 * @brief General purpose policy for unary <tt>*X</tt> lambda expressions.
 *
 @code
    *X
 @endcode
 * where X is an instance of a lambda primitive.
 *
 * @tparam CapacityT
 *        specifies capacity of the lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int CapacityT, int PrimitiveIdT > 
struct xst_dereference_policy {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_dereference;

    /**Implementation of dereference operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>*X</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "(*" );
        CTTL_TRACE_DEPOSIT_LINE( "A<X_,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return *lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of <tt>*X</tt> is lvalue.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        Mutable reference to dereferenced operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    lvalue_ref( LambdaT& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "(*" );
        CTTL_TRACE_DEPOSIT_LINE( "A<X_,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return *lambda_.top( const_scalar( 0 ) );
    }

    /**Lambda expresion <tt>*U</tt> has no side effects.*/
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& )
    {
    }

    /**Lambda expresion <tt>*U</tt> has no side effects.*/
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>*U</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>*X</tt> always succeeds.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // kleene star
        CTTL_TRACE_DEPOSIT_TEXT( "kleene*" );
        lambda_.top( const_scalar( 0 ) );
        return edge_.first.offset();
    }

}; // xst_dereference_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:20
// generated by bin\gmu\gmu_lambda\operators/dereference/stack_dereference_adaptor.h:1

// *S -> A<S_,istack>, where A := xst_dereference_policy< CapacityT, primitive_id_stack >

/**@struct xst_dereference_policy< CapacityT, primitive_id_stack >
 * @brief Partial policy specialization for unary <tt>*S</tt> lambda expressions.
 *
 @code
    *S
 @endcode
 * where S is an instance of a cttl_impl::xst_stack.
 *
 * @tparam CapacityT
 *        specifies capacity of the lambda operand.
 *
 * @remarks
 * Dereference operator specialization for stack primitives.
 * When dereference operator applied to stack primitive, it returns
 * mutable reference of the value on top of the stack.
 *
 */
template< int CapacityT >
struct xst_dereference_policy< CapacityT, primitive_id_stack > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_dereference;

    /**Implementation of dereference operator for
    *  stack refererence lambda primitive.
    *
    * @tparam LambdaT
    *        specifies type of
    *        encapsulated lambda operand.
    *
    * @pre
    *        Stack should not be empty.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        Returns copy of value on top of the stack.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "(*" );
        CTTL_TRACE_DEPOSIT_LINE( "A<S_,istack>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lambda_.top( const_scalar( 0 ) );
    }

    /**Implementation of dereference operator for
    *  stack refererence lambda primitive.
    *
    * @tparam LambdaT
    *        specifies type of
    *        encapsulated lambda operand.
    *
    * @pre
    *        Stack should not be empty.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        Returns mutable reference to the value on top of the stack.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    lvalue_ref( LambdaT& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "(*" );
        CTTL_TRACE_DEPOSIT_LINE( "A<S_,istack>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lambda_.top( const_scalar( 0 ) );
    }

    /**Lambda expresion <tt>*S</tt> has no side effects.*/
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& )
    {
    }

    /**Lambda expresion <tt>*S</tt> has no side effects.*/
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>*S</tt> always succeeds.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // kleene star
        return xst_dereference_policy< LambdaT::capacity_, primitive_id_unspecified >::match( lambda_, edge_ );
    }

}; // xst_dereference_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:23
// generated by bin\gmu\gmu_lambda\operators/dereference/dereference_4_unary_adaptor.h:1

// *U -> A<U_,iunary>, where A := xst_dereference_policy< CapacityT, primitive_id_unary_adaptor >

/**@struct xst_dereference_policy< CapacityT, primitive_id_unary_adaptor >
 * @brief General purpose policy for unary <tt>*</tt> lambda expressions.
 *
 @code
    *U
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam CapacityT
 *        specifies capacity of the lambda operand.
 *
 */
template< int CapacityT >
struct xst_dereference_policy< CapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_dereference;

    /**Implementation of dereference operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>*U</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "(*" );
        CTTL_TRACE_DEPOSIT_LINE( "A<U_,iunary>" );
        const_cast< LambdaT* >( &lambda_ )->prefix_side_effects();    // fulfill side effects
        typename LambdaT::dereferenced_value_T value = const_cast< LambdaT* >( &lambda_ )->dereferenced_value();
        const_cast< LambdaT* >( &lambda_ )->postfix_side_effects();
        CTTL_TRACE_DEPOSIT_TEXT( ") " );
        return value;
    }

    /**Lvalue support: result of <tt>*U</tt> is lvalue.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        Mutable reference to dereferenced operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    lvalue_ref( LambdaT& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "(*" );
        CTTL_TRACE_DEPOSIT_LINE( "A<U_,iunary>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lambda_.dereferenced_value();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>*U</tt>.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& lambda_ )
    {
        lambda_.prefix_side_effects();
    }

    /**Fulfills postfix side effects for lambda expresion <tt>*U</tt>.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& lambda_ )
    {
        lambda_.postfix_side_effects();
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>*U</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>*U</tt> always succeeds.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // kleene star
        return xst_dereference_policy< LambdaT::capacity_, primitive_id_unspecified >::match( lambda_, edge_ );
    }

}; // xst_dereference_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:367
// generated by bin/gmu/gmu_lambda/gmu_common.h:33
// generated by bin\gmu\gmu_lambda\operators/unary_prefix/unary_prefix_adaptor.h:1

// ++X -> A<X_,id>, where A := xst_prefix_increment_policy< CapacityT, PrimitiveIdT >

/**@struct xst_prefix_increment_policy
 * @brief General purpose policy for prefix expression <tt>++X</tt>.
 *
 @code
    ++X
 @endcode
 * where X is lambda primitive.
 *
 * @tparam CapacityT
 *        specifies capacity of lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify lambda primitive.
 *
 */
template< int CapacityT, int PrimitiveIdT > 
struct xst_prefix_increment_policy {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of prefix increment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>++X</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( ++ " );
        CTTL_TRACE_DEPOSIT_LINE( "A<X_,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return ++const_cast< LambdaT* >( &lambda_ )->top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of <tt>++X</tt> is lvalue.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        Mutable reference to operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T&
    lvalue_ref( LambdaT& lambda_ )
    {
        return lambda_.top( const_scalar( 0 ) );
    }

    /**Provides mutable access to dereferenced operand.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *       Mutable reference to dereferenced operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    dereferenced_lvalue( LambdaT& lambda_ )
    {
        return lambda_.dereferenced_value();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>++X</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& lambda_ )
    {
        top( lambda_ );
    }

    /**Lambda expresion <tt>++X</tt> has no side effects.*/
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>++X</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>++X</tt> succeeds if integral result of lambda
    *    expression <tt>++X</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_prefix_increment_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:36
// generated by bin\gmu\gmu_lambda\operators/unary_prefix/prefix_adaptor_4_unary_adaptors.h:1

// ++U -> A<U_,iunary>, where A := xst_prefix_increment_policy< CapacityT, primitive_id_unary_adaptor >

/**@struct xst_prefix_increment_policy< CapacityT, primitive_id_unary_adaptor >
 * @brief Partial specialization policy for prefix expression <tt>++U</tt>.
 *
 @code
    ++U
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam CapacityT
 *        specifies capacity of U.
 *
 */
template< int CapacityT >
struct xst_prefix_increment_policy< CapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of prefix increment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>++U</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( ++ " );
        CTTL_TRACE_DEPOSIT_LINE( "A<U_,iunary>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        const_cast< LambdaT* >( &lambda_ )->prefix_side_effects();
        typename LambdaT::value_T value = ++const_cast< LambdaT* >( &lambda_ )->lvalue_ref();
        const_cast< LambdaT* >( &lambda_ )->postfix_side_effects();
        return value;
    }

    /**Lvalue support: result of <tt>++U</tt> is lvalue.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        Mutable reference to operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T&
    lvalue_ref( LambdaT& lambda_ )
    {
        return lambda_.lvalue_ref();
    }

    /**Provides mutable access to dereferenced operand.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *       Mutable reference to dereferenced operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    dereferenced_lvalue( LambdaT& lambda_ )
    {
        return lambda_.dereferenced_value();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>++U</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& lambda_ )
    {
        top( lambda_ );
    }

    /**Lambda expresion <tt>++U</tt> has no side effects.*/
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>++U</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>++U</tt> succeeds if integral result of lambda
    *    expression <tt>++U</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_prefix_increment_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:371
// generated by bin/gmu/gmu_lambda/gmu_common.h:66
// generated by bin\gmu\gmu_lambda\operators/unary_prefix/translator_prefix_inc_adaptor.h:1

// ++T -> A<T_,itran>, where A := xst_prefix_increment_policy< CapacityT, primitive_id_translator >

/**@struct xst_prefix_increment_policy< CapacityT, primitive_id_translator >
 * @brief Partial specialization policy for prefix expression <tt>++T</tt>.
 *
 @code
    ++T
 @endcode
 * where T is an instance of cttl_impl::xst_translator.
 *
 * @tparam CapacityT
 *        specifies capacity of T.
 *
 */
template< int CapacityT >
struct xst_prefix_increment_policy< CapacityT, primitive_id_translator > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_prefix_increment;

    /**Implementation of prefix increment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>++T</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( ++ " );
        CTTL_TRACE_DEPOSIT_LINE( "A<T_,itran>" );
        const_cast< LambdaT* >( &lambda_ )->push( const_scalar( 0 ), true );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of <tt>++T</tt> is lvalue.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        Mutable reference to operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T&
    lvalue_ref( LambdaT& lambda_ )
    {
        return lambda_.top( const_scalar( 0 ) );
    }

    /**Provides mutable access to dereferenced operand.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *       Mutable reference to dereferenced operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    dereferenced_lvalue( LambdaT& lambda_ )
    {
        return lambda_.dereferenced_value();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>++T</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& lambda_ )
    {
        top( lambda_ );
    }

    /**Lambda expresion <tt>++T</tt> has no side effects.*/
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>++T</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>++T</tt> succeeds if integral result of lambda
    *    expression <tt>++T</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_prefix_increment_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:390
// generated by bin/gmu/gmu_lambda/gmu_common.h:85
// generated by bin\gmu\gmu_lambda\operators/unary_postfix/unary_postfix_adaptor.h:2

// X++ -> A<X_,id>, where A := xst_postfix_increment_policy< CapacityT, PrimitiveIdT >

/**@struct xst_postfix_increment_policy
 * @brief General purpose policy for postfix expression <tt>X++</tt>.
 *
 @code
    X++
 @endcode
 * where X is lambda primitive.
 *
 * @tparam CapacityT
 *        specifies capacity of lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify lambda primitive.
 *
 */
template< int CapacityT, int PrimitiveIdT > 
struct xst_postfix_increment_policy {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of postfix increment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X++</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( " );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( '+' );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( '+' );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return ( const_cast< LambdaT* >( &lambda_ )->top( const_scalar( 0 ) ) )++;
    }

    /**Provides mutable access to dereferenced operand.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *       Mutable reference to dereferenced operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    dereferenced_lvalue( LambdaT& lambda_ )
    {
        return lambda_.dereferenced_value();
    }

    /**Lambda expresion <tt>X++</tt> has no prefix side effects.*/
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& )
    {
    }

    /**Fulfills postfix side effects for lambda expresion <tt>X++</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& lambda_ )
    {
        top( lambda_ );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X++</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X++</tt> succeeds if integral result of lambda
    *    expression <tt>X++</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_postfix_increment_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:88
// generated by bin\gmu\gmu_lambda\operators/unary_postfix/postfix_adaptor_4_unary_adaptors.h:2

// U++ -> A<U_,iunary>, where A := xst_postfix_increment_policy< CapacityT, primitive_id_unary_adaptor >

/**@struct xst_postfix_increment_policy< CapacityT, primitive_id_unary_adaptor >
 * @brief Partial specialization policy for postfix expression <tt>U++</tt>.
 *
 @code
    U++
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam CapacityT
 *        specifies capacity of U.
 *
 */
template< int CapacityT >
struct xst_postfix_increment_policy< CapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of postfix increment operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>U++</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( " );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( '+' );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( '+' );
        const_cast< LambdaT* >( &lambda_ )->prefix_side_effects();
        typename LambdaT::value_T value = const_cast< LambdaT* >( &lambda_ )->lvalue_ref()++;
        const_cast< LambdaT* >( &lambda_ )->postfix_side_effects();
        return value;
    }

    /**Provides mutable access to dereferenced operand.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *       Mutable reference to dereferenced operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    dereferenced_lvalue( LambdaT& lambda_ )
    {
        return lambda_.dereferenced_value();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U++</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& lambda_ )
    {
        lambda_.prefix_side_effects();
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U++</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( " );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( '+' );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( '+' );
        ++lambda_.lvalue_ref();
        lambda_.postfix_side_effects();
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U++</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U++</tt> succeeds if integral result of lambda
    *    expression <tt>U++</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_postfix_increment_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:444
// generated by bin/gmu/gmu_lambda/gmu_common.h:33
// generated by bin\gmu\gmu_lambda\operators/unary_prefix/unary_prefix_adaptor.h:1

// --X -> A<X_,id>, where A := xst_prefix_decrement_policy< CapacityT, PrimitiveIdT >

/**@struct xst_prefix_decrement_policy
 * @brief General purpose policy for prefix expression <tt>--X</tt>.
 *
 @code
    --X
 @endcode
 * where X is lambda primitive.
 *
 * @tparam CapacityT
 *        specifies capacity of lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify lambda primitive.
 *
 */
template< int CapacityT, int PrimitiveIdT > 
struct xst_prefix_decrement_policy {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of prefix decrement operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>--X</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( -- " );
        CTTL_TRACE_DEPOSIT_LINE( "A<X_,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return --const_cast< LambdaT* >( &lambda_ )->top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of <tt>--X</tt> is lvalue.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        Mutable reference to operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T&
    lvalue_ref( LambdaT& lambda_ )
    {
        return lambda_.top( const_scalar( 0 ) );
    }

    /**Provides mutable access to dereferenced operand.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *       Mutable reference to dereferenced operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    dereferenced_lvalue( LambdaT& lambda_ )
    {
        return lambda_.dereferenced_value();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>--X</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& lambda_ )
    {
        top( lambda_ );
    }

    /**Lambda expresion <tt>--X</tt> has no side effects.*/
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>--X</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>--X</tt> succeeds if integral result of lambda
    *    expression <tt>--X</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_prefix_decrement_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:36
// generated by bin\gmu\gmu_lambda\operators/unary_prefix/prefix_adaptor_4_unary_adaptors.h:1

// --U -> A<U_,iunary>, where A := xst_prefix_decrement_policy< CapacityT, primitive_id_unary_adaptor >

/**@struct xst_prefix_decrement_policy< CapacityT, primitive_id_unary_adaptor >
 * @brief Partial specialization policy for prefix expression <tt>--U</tt>.
 *
 @code
    --U
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam CapacityT
 *        specifies capacity of U.
 *
 */
template< int CapacityT >
struct xst_prefix_decrement_policy< CapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of prefix decrement operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>--U</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( -- " );
        CTTL_TRACE_DEPOSIT_LINE( "A<U_,iunary>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        const_cast< LambdaT* >( &lambda_ )->prefix_side_effects();
        typename LambdaT::value_T value = --const_cast< LambdaT* >( &lambda_ )->lvalue_ref();
        const_cast< LambdaT* >( &lambda_ )->postfix_side_effects();
        return value;
    }

    /**Lvalue support: result of <tt>--U</tt> is lvalue.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        Mutable reference to operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T&
    lvalue_ref( LambdaT& lambda_ )
    {
        return lambda_.lvalue_ref();
    }

    /**Provides mutable access to dereferenced operand.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *       Mutable reference to dereferenced operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    dereferenced_lvalue( LambdaT& lambda_ )
    {
        return lambda_.dereferenced_value();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>--U</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& lambda_ )
    {
        top( lambda_ );
    }

    /**Lambda expresion <tt>--U</tt> has no side effects.*/
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>--U</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>--U</tt> succeeds if integral result of lambda
    *    expression <tt>--U</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_prefix_decrement_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:448
// generated by bin/gmu/gmu_lambda/gmu_common.h:76
// generated by bin\gmu\gmu_lambda\operators/unary_prefix/translator_prefix_dec_adaptor.h:1

// --T -> A<T_,itran>, where A := xst_prefix_decrement_policy< CapacityT, primitive_id_translator >

/**@struct xst_prefix_decrement_policy< CapacityT, primitive_id_translator >
 * @brief Partial specialization policy for prefix expression <tt>--T</tt>.
 *
 @code
    --T
 @endcode
 * where T is an instance of cttl_impl::xst_translator.
 *
 * @tparam CapacityT
 *        specifies capacity of T.
 *
 */
template< int CapacityT >
struct xst_prefix_decrement_policy< CapacityT, primitive_id_translator > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_prefix_decrement;

    /**Implementation of prefix decrement operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>--T</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( -- " );
        CTTL_TRACE_DEPOSIT_LINE( "A<T_,itran>" );
        const_cast< LambdaT* >( &lambda_ )->push( const_scalar( 0 ), false );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lambda_.top( const_scalar( 0 ) );
    }

    /**Lvalue support: result of <tt>--T</tt> is lvalue.
    *
    * @tparam LambdaT
    *        specifies type of
    *        lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        Mutable reference to operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T&
    lvalue_ref( LambdaT& lambda_ )
    {
        return lambda_.top( const_scalar( 0 ) );
    }

    /**Provides mutable access to dereferenced operand.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *       Mutable reference to dereferenced operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    dereferenced_lvalue( LambdaT& lambda_ )
    {
        return lambda_.dereferenced_value();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>--T</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& lambda_ )
    {
        top( lambda_ );
    }

    /**Lambda expresion <tt>--T</tt> has no side effects.*/
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>--T</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>--T</tt> succeeds if integral result of lambda
    *    expression <tt>--T</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_prefix_decrement_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:454
// generated by bin/gmu/gmu_lambda/gmu_common.h:56
// generated by bin\gmu\gmu_lambda\operators/unary_prefix/stackpop_prefix_dec_adaptor.h:1

// --S -> A<S_,istack>, where A := xst_prefix_decrement_policy< CapacityT, primitive_id_stack >

/**@struct xst_prefix_decrement_policy< CapacityT, primitive_id_stack >
 * @brief Partial specialization policy for prefix expression <tt>--S</tt>.
 *
 @code
    --S
 @endcode
 * where S is an instance of cttl_impl::xst_stack.
 *
 * @tparam CapacityT
 *        specifies capacity of stack primitive.
 *
 */
template< int CapacityT >
struct xst_prefix_decrement_policy< CapacityT, primitive_id_stack > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_stack_prefix_decrement;

    /**Implementation of prefix decrement operator for
    *  stack primitive.
    *
    * @tparam LambdaT
    *        specifies type of stack primitive.
    *
    * @pre
    *        Stack should not be empty.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns stack size after
    *        <tt>--S</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename xst_unary_operator_traits<
        typename LambdaT::value_T,
        typename LambdaT::dereferenced_value_T,
        operator_id_stack_prefix_decrement
    >::value_type
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( -- size$" );
        CTTL_TRACE_DEPOSIT_TEXT( lambda_.size( const_scalar( 0 ) ) );
        CTTL_TRACE_DEPOSIT_TEXT( ' ' );
        const_cast< LambdaT* >( &lambda_ )->pop( const_scalar( 0 ) );
        CTTL_TRACE_DEPOSIT_LINE( "A<S_,istack>" );
        CTTL_TRACE_DEPOSIT_TEXT( " ) " );
        return lambda_.size( const_scalar( 0 ) );
    }

    /**Provides mutable access to dereferenced stack operand.
    *
    * @tparam LambdaT
    *        specifies type of stack primitive.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        Returns mutable reference to the value on top of the stack.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    dereferenced_lvalue( LambdaT& lambda_ )
    {
        return lambda_.dereferenced_value();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>--S</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& lambda_ )
    {
        top( lambda_ );
    }

    /**Lambda expresion <tt>--S</tt> has no postfix side effects.*/
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& )
    {
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>S--</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>--S</tt> succeeds if integral result of lambda
    *    expression <tt>--S</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_prefix_decrement_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:473
// generated by bin/gmu/gmu_lambda/gmu_common.h:85
// generated by bin\gmu\gmu_lambda\operators/unary_postfix/unary_postfix_adaptor.h:2

// X-- -> A<X_,id>, where A := xst_postfix_decrement_policy< CapacityT, PrimitiveIdT >

/**@struct xst_postfix_decrement_policy
 * @brief General purpose policy for postfix expression <tt>X--</tt>.
 *
 @code
    X--
 @endcode
 * where X is lambda primitive.
 *
 * @tparam CapacityT
 *        specifies capacity of lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify lambda primitive.
 *
 */
template< int CapacityT, int PrimitiveIdT > 
struct xst_postfix_decrement_policy {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of postfix decrement operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>X--</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( " );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( '-' );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( '-' );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return ( const_cast< LambdaT* >( &lambda_ )->top( const_scalar( 0 ) ) )--;
    }

    /**Provides mutable access to dereferenced operand.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *       Mutable reference to dereferenced operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    dereferenced_lvalue( LambdaT& lambda_ )
    {
        return lambda_.dereferenced_value();
    }

    /**Lambda expresion <tt>X--</tt> has no prefix side effects.*/
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& )
    {
    }

    /**Fulfills postfix side effects for lambda expresion <tt>X--</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& lambda_ )
    {
        top( lambda_ );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>X--</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>X--</tt> succeeds if integral result of lambda
    *    expression <tt>X--</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_postfix_decrement_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:88
// generated by bin\gmu\gmu_lambda\operators/unary_postfix/postfix_adaptor_4_unary_adaptors.h:2

// U-- -> A<U_,iunary>, where A := xst_postfix_decrement_policy< CapacityT, primitive_id_unary_adaptor >

/**@struct xst_postfix_decrement_policy< CapacityT, primitive_id_unary_adaptor >
 * @brief Partial specialization policy for postfix expression <tt>U--</tt>.
 *
 @code
    U--
 @endcode
 * where U is an instance of cttl_impl::xst_unary_adaptor.
 *
 * @tparam CapacityT
 *        specifies capacity of U.
 *
 */
template< int CapacityT >
struct xst_postfix_decrement_policy< CapacityT, primitive_id_unary_adaptor > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of postfix decrement operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>U--</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( " );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( '-' );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( '-' );
        const_cast< LambdaT* >( &lambda_ )->prefix_side_effects();
        typename LambdaT::value_T value = const_cast< LambdaT* >( &lambda_ )->lvalue_ref()--;
        const_cast< LambdaT* >( &lambda_ )->postfix_side_effects();
        return value;
    }

    /**Provides mutable access to dereferenced operand.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *       Mutable reference to dereferenced operand.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    dereferenced_lvalue( LambdaT& lambda_ )
    {
        return lambda_.dereferenced_value();
    }

    /**Fulfills prefix side effects for lambda expresion <tt>U--</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& lambda_ )
    {
        lambda_.prefix_side_effects();
    }

    /**Fulfills postfix side effects for lambda expresion <tt>U--</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( " );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( '-' );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( '-' );
        --lambda_.lvalue_ref();
        lambda_.postfix_side_effects();
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>U--</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>U--</tt> succeeds if integral result of lambda
    *    expression <tt>U--</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_postfix_decrement_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:479
// generated by bin/gmu/gmu_lambda/gmu_common.h:46
// generated by bin\gmu\gmu_lambda\operators/unary_postfix/stackpop_postfix_dec_adaptor.h:1

// S-- -> A<S_,istack>, where A := xst_postfix_decrement_policy< CapacityT, primitive_id_stack >

/**@struct xst_postfix_decrement_policy< CapacityT, primitive_id_stack >
 * @brief Partial specialization policy for postfix expression <tt>S--</tt>.
 *
 @code
    S--
 @endcode
 * where S is an instance of cttl_impl::xst_stack.
 *
 * @tparam CapacityT
 *        specifies capacity of S.
 *
 */
template< int CapacityT >
struct xst_postfix_decrement_policy< CapacityT, primitive_id_stack > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_stack_postfix_decrement;

    /**Implementation of postfix decrement operator for
    *  stack primitive.
    *
    * @tparam LambdaT
    *        specifies type of stack primitive.
    *
    * @pre
    *        Stack should not be empty.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns stack size before
    *        <tt>S--</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename xst_unary_operator_traits<
        typename LambdaT::value_T,
        typename LambdaT::dereferenced_value_T,
        operator_id_stack_postfix_decrement
    >::value_type
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( size$" );
        CTTL_TRACE_DEPOSIT_TEXT( lambda_.size( const_scalar( 0 ) ) );
        CTTL_TRACE_DEPOSIT_TEXT( ' ' );
        const_cast< LambdaT* >( &lambda_ )->pop( const_scalar( 0 ) );
        CTTL_TRACE_DEPOSIT_LINE( "A<S_,istack>" );
        CTTL_TRACE_DEPOSIT_TEXT( "-- ) " );
        return lambda_.size( const_scalar( 0 ) ) + 1;
    }

    /**Provides mutable access to dereferenced stack operand.
    *
    * @tparam LambdaT
    *        specifies type of stack primitive.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        Returns mutable reference to the value on top of the stack.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::dereferenced_value_T&
    dereferenced_lvalue( LambdaT& lambda_ )
    {
        return lambda_.dereferenced_value();
    }

    /**Lambda expresion <tt>S--</tt> has no side effects.*/
    template< typename LambdaT >
    static void prefix_side_effects( LambdaT& )
    {
    }

    /**Fulfills postfix side effects for lambda expresion <tt>S--</tt>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    */
    template< typename LambdaT >
    static void postfix_side_effects( LambdaT& lambda_ )
    {
        top( lambda_ );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>S--</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>S--</tt> succeeds if integral result of lambda
    *    expression <tt>S--</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_postfix_decrement_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:291
// generated by bin\gmu\gmu_lambda\operators/unary_plus/unary_plus_adaptor.h:2

// +D -> A<D_,id>, where A := xst_rvalue_policy< CapacityT, PrimitiveIdT >

/**@struct xst_rvalue_policy
 * @brief General purpose unary + runtime policy.
 *
 @code
    +D
 @endcode
 * where D is lambda expression.
 *
 * @tparam CapacityT
 *        specifies capacity of the lambda operand.
 *
 * @tparam PrimitiveIdT
 *        specifies type of
 *        left-hand-side lambda operand.
 *
 */
template< int CapacityT, int PrimitiveIdT > 
struct xst_rvalue_policy {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of plus operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>+D</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename LambdaT::value_T
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_LINE( "A<D_,id>" );
        CTTL_TRACE_DEPOSIT_TEXT( "+" );
        return +lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand: an <a href="http://cttl.sourceforge.net/cttl300docs/manual/lambda/page0150_grammar.html">integral lambda expression</a>
    *        convertible to @c size_t.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>+D</tt> is integral type.
    *
    * @post
    *        This algorithm always succeeds and returns current
    *        substring position. Left hand side of the
    *        substring is advanced by adding result of lambda
    *        expression evaluation to the current position.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>+D</tt> always succeeds.
    *    The function returns new left hand side position of the substring, calculated
    *    by adding result of <tt>+D</tt> lambda expression to the current position.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT& edge_ )
    {
        // kleene plus
        CTTL_TRACE_DEPOSIT_TEXT( "kleene" );
        size_t result = top( lambda_ );
        if ( result == SubstrT::string_T::npos )
            return result;

        if ( ( edge_.first.offset() + result ) > edge_.second.offset() ) {
            // Direct parser is ungreedy: a shorter match is okay:
            return edge_.first.offset( edge_.second.offset() );
        }

        return edge_.first.offset( edge_.first.offset() + result );
    }

}; // xst_rvalue_policy

// generated by bin/gmu/gmu_lambda/gmu_common.h:295

// generated by bin\gmu\gmu_lambda\operators/unary_plus/unary_plus_4_stack_adaptor.h:3

// +S -> A<S_,istack>, where A := xst_rvalue_policy< CapacityT, primitive_id_stack >

/**@struct xst_rvalue_policy< CapacityT, primitive_id_stack >
 * @brief Partial specialization for unary + runtime policy.
 *
 @code
    +S
 @endcode
 * where S is stack primitive cttl_impl::xst_stack.
 *
 * @tparam CapacityT
 *        specifies capacity of the operand.
 *
 */
template< int CapacityT >
struct xst_rvalue_policy< CapacityT, primitive_id_stack > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_stack_unary_plus;

    /**Implementation of plus operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        expression <tt>+S</tt> returns size of the stack.
    *
    */
    template< typename LambdaT >
    static
    typename xst_unary_operator_traits<
        typename LambdaT::value_T,
        typename LambdaT::dereferenced_value_T,
        operator_id_stack_unary_plus
    >::value_type
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_LINE( "A<S_,istack>" );
        CTTL_TRACE_DEPOSIT_TEXT( "+size$" );
        CTTL_TRACE_DEPOSIT_TEXT( lambda_.size( const_scalar( 0 ) ) );
        CTTL_TRACE_DEPOSIT_TEXT( ' ' );
        return lambda_.size( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>+S</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>+S</tt> succeeds if integral result of lambda
    *    expression <tt>+S</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_rvalue_policy

// generated by bin/gmu/gmu_lambda/unary_adaptors.h:16
// generated by bin/gmu/gmu_lambda/unary_adaptors.h:4
// generated by bin\gmu\gmu_lambda\operators/gp_unary_adaptor.h:2
// -D -> A<D_,id>, where A := xst_unary_minus_policy< int CapacityT, int PrimitiveIdT >
/**@struct xst_unary_minus_policy
 * @brief General purpose policy for unary <tt>-</tt> lambda expression.
 *
 @code
    -D
 @endcode
 * where D is lambda primitive.
 *
 * @tparam CapacityT
 *        specifies capacity of lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify lambda primitive.
 *
 */
template< int CapacityT, int PrimitiveIdT > 
struct xst_unary_minus_policy {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of unary minus operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>-D</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename xst_unary_operator_traits<
        typename LambdaT::value_T,
        typename LambdaT::dereferenced_value_T,
        operator_id_
    >::value_type
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "-" );
        CTTL_TRACE_DEPOSIT_LINE( "A<D_,id>" );
        return -lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>-D</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>-D</tt> succeeds if integral result of lambda
    *    expression <tt>-D</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_unary_minus_policy

// generated by bin/gmu/gmu_lambda/unary_adaptors.h:34
// generated by bin/gmu/gmu_lambda/unary_adaptors.h:4
// generated by bin\gmu\gmu_lambda\operators/gp_unary_adaptor.h:2
// ~D -> A<D_,id>, where A := xst_bitwise_not_policy< int CapacityT, int PrimitiveIdT >
/**@struct xst_bitwise_not_policy
 * @brief General purpose policy for unary <tt>~</tt> lambda expression.
 *
 @code
    ~D
 @endcode
 * where D is lambda primitive.
 *
 * @tparam CapacityT
 *        specifies capacity of lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify lambda primitive.
 *
 */
template< int CapacityT, int PrimitiveIdT > 
struct xst_bitwise_not_policy {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of bitwise not operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>~D</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename xst_unary_operator_traits<
        typename LambdaT::value_T,
        typename LambdaT::dereferenced_value_T,
        operator_id_
    >::value_type
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "~" );
        CTTL_TRACE_DEPOSIT_LINE( "A<D_,id>" );
        return ~lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>~D</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>~D</tt> succeeds if integral result of lambda
    *    expression <tt>~D</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_not_policy

// generated by bin/gmu/gmu_lambda/unary_adaptors.h:52
// generated by bin/gmu/gmu_lambda/unary_adaptors.h:4
// generated by bin\gmu\gmu_lambda\operators/gp_unary_adaptor.h:2
// !D -> A<D_,id>, where A := xst_logical_not_policy< int CapacityT, int PrimitiveIdT >
/**@struct xst_logical_not_policy
 * @brief General purpose policy for unary <tt>!</tt> lambda expression.
 *
 @code
    !D
 @endcode
 * where D is lambda primitive.
 *
 * @tparam CapacityT
 *        specifies capacity of lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify lambda primitive.
 *
 */
template< int CapacityT, int PrimitiveIdT > 
struct xst_logical_not_policy {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of logical not operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>!D</tt>.
    *
    */
    template< typename LambdaT >
    static
    typename xst_unary_operator_traits<
        typename LambdaT::value_T,
        typename LambdaT::dereferenced_value_T,
        operator_id_
    >::value_type
    top( LambdaT const& lambda_ )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "!" );
        CTTL_TRACE_DEPOSIT_LINE( "A<D_,id>" );
        return !lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaT
    *        specifies type of lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lambda_
    *        lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>!D</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>!D</tt> succeeds if integral result of lambda
    *    expression <tt>!D</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaT, typename SubstrT >
    static size_t match( LambdaT const& lambda_, SubstrT const& edge_ )
    {
        // switch
        if ( top( lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_logical_not_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:20
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_add_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_add_policy {
};//xst_add_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L+R -> A<R_=1,L_=1,id>, where A := xst_add_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_add_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>+</tt> lambda expressions.
 *
 @code
    L+R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_add_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of addition operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L+R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( + " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) + rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L+R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L+R</tt> succeeds if integral result of lambda
    *    expression <tt>L+R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_add_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L+M -> A<M_,L_=1,id>, where A := xst_add_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_add_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>+</tt> lambda expressions.
 *
 @code
    L+M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_add_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of addition operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L+M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( + " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) + rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L+M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L+M</tt> succeeds if integral result of lambda
    *    expression <tt>L+M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_add_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:39
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_multiplication_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_multiplication_policy {
};//xst_multiplication_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L*R -> A<R_=1,L_=1,id>, where A := xst_multiplication_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_multiplication_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>*</tt> lambda expressions.
 *
 @code
    L*R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_multiplication_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of multiplication operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L*R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( * " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) * rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L*R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L*R</tt> succeeds if integral result of lambda
    *    expression <tt>L*R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_multiplication_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L*M -> A<M_,L_=1,id>, where A := xst_multiplication_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_multiplication_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>*</tt> lambda expressions.
 *
 @code
    L*M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_multiplication_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of multiplication operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L*M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( * " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) * rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L*M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L*M</tt> succeeds if integral result of lambda
    *    expression <tt>L*M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_multiplication_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:58
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_division_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_division_policy {
};//xst_division_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L/R -> A<R_=1,L_=1,id>, where A := xst_division_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_division_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>/</tt> lambda expressions.
 *
 @code
    L/R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_division_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of division operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L/R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( / " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) / rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L/R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L/R</tt> succeeds if integral result of lambda
    *    expression <tt>L/R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_division_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L/M -> A<M_,L_=1,id>, where A := xst_division_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_division_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>/</tt> lambda expressions.
 *
 @code
    L/M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_division_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of division operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L/M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( / " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) / rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L/M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L/M</tt> succeeds if integral result of lambda
    *    expression <tt>L/M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_division_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:77
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_modulus_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_modulus_policy {
};//xst_modulus_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L%R -> A<R_=1,L_=1,id>, where A := xst_modulus_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_modulus_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>%</tt> lambda expressions.
 *
 @code
    L%R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_modulus_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of modulus operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L%R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( % " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) % rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L%R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L%R</tt> succeeds if integral result of lambda
    *    expression <tt>L%R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_modulus_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L%M -> A<M_,L_=1,id>, where A := xst_modulus_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_modulus_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>%</tt> lambda expressions.
 *
 @code
    L%M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_modulus_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of modulus operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L%M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( % " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) % rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L%M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L%M</tt> succeeds if integral result of lambda
    *    expression <tt>L%M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_modulus_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:96
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_binary_minus_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_binary_minus_policy {
};//xst_binary_minus_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L-R -> A<R_=1,L_=1,id>, where A := xst_binary_minus_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_binary_minus_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>-</tt> lambda expressions.
 *
 @code
    L-R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_binary_minus_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of binary minus operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L-R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( - " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) - rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L-R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L-R</tt> succeeds if integral result of lambda
    *    expression <tt>L-R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_binary_minus_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L-M -> A<M_,L_=1,id>, where A := xst_binary_minus_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_binary_minus_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>-</tt> lambda expressions.
 *
 @code
    L-M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_binary_minus_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of binary minus operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L-M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( - " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) - rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L-M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L-M</tt> succeeds if integral result of lambda
    *    expression <tt>L-M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_binary_minus_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:115
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_bitwise_left_shift_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_bitwise_left_shift_policy {
};//xst_bitwise_left_shift_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L<<R -> A<R_=1,L_=1,id>, where A := xst_bitwise_left_shift_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_left_shift_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt><<</tt> lambda expressions.
 *
 @code
    L<<R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_bitwise_left_shift_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of bitwise left shift operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L<<R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( << " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) << rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L<<R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L<<R</tt> succeeds if integral result of lambda
    *    expression <tt>L<<R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_left_shift_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L<<M -> A<M_,L_=1,id>, where A := xst_bitwise_left_shift_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_left_shift_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt><<</tt> lambda expressions.
 *
 @code
    L<<M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_bitwise_left_shift_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of bitwise left shift operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L<<M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( << " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) << rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L<<M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L<<M</tt> succeeds if integral result of lambda
    *    expression <tt>L<<M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_left_shift_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:134
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_bitwise_right_shift_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_bitwise_right_shift_policy {
};//xst_bitwise_right_shift_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L>>R -> A<R_=1,L_=1,id>, where A := xst_bitwise_right_shift_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_right_shift_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>>></tt> lambda expressions.
 *
 @code
    L>>R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_bitwise_right_shift_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of bitwise right shift operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L>>R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( >> " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) >> rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L>>R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L>>R</tt> succeeds if integral result of lambda
    *    expression <tt>L>>R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_right_shift_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L>>M -> A<M_,L_=1,id>, where A := xst_bitwise_right_shift_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_right_shift_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>>></tt> lambda expressions.
 *
 @code
    L>>M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_bitwise_right_shift_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of bitwise right shift operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L>>M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( >> " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) >> rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L>>M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L>>M</tt> succeeds if integral result of lambda
    *    expression <tt>L>>M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_right_shift_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:153
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_relational_less_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_relational_less_policy {
};//xst_relational_less_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L<R -> A<R_=1,L_=1,id>, where A := xst_relational_less_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_relational_less_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt><</tt> lambda expressions.
 *
 @code
    L<R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_relational_less_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of relational less operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L<R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( < " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) < rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L<R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L<R</tt> succeeds if integral result of lambda
    *    expression <tt>L<R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_relational_less_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L<M -> A<M_,L_=1,id>, where A := xst_relational_less_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_relational_less_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt><</tt> lambda expressions.
 *
 @code
    L<M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_relational_less_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of relational less operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L<M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( < " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) < rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L<M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L<M</tt> succeeds if integral result of lambda
    *    expression <tt>L<M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_relational_less_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:172
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_relational_less_equal_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_relational_less_equal_policy {
};//xst_relational_less_equal_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L<=R -> A<R_=1,L_=1,id>, where A := xst_relational_less_equal_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_relational_less_equal_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt><=</tt> lambda expressions.
 *
 @code
    L<=R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_relational_less_equal_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of relational less equal operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L<=R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( <= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) <= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L<=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L<=R</tt> succeeds if integral result of lambda
    *    expression <tt>L<=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_relational_less_equal_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L<=M -> A<M_,L_=1,id>, where A := xst_relational_less_equal_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_relational_less_equal_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt><=</tt> lambda expressions.
 *
 @code
    L<=M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_relational_less_equal_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of relational less equal operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L<=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( <= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) <= rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L<=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L<=M</tt> succeeds if integral result of lambda
    *    expression <tt>L<=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_relational_less_equal_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:191
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_relational_greater_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_relational_greater_policy {
};//xst_relational_greater_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L>R -> A<R_=1,L_=1,id>, where A := xst_relational_greater_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_relational_greater_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>></tt> lambda expressions.
 *
 @code
    L>R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_relational_greater_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of relational greater operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L>R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( > " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) > rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L>R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L>R</tt> succeeds if integral result of lambda
    *    expression <tt>L>R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_relational_greater_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L>M -> A<M_,L_=1,id>, where A := xst_relational_greater_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_relational_greater_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>></tt> lambda expressions.
 *
 @code
    L>M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_relational_greater_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of relational greater operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L>M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( > " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) > rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L>M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L>M</tt> succeeds if integral result of lambda
    *    expression <tt>L>M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_relational_greater_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:210
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_relational_greater_equal_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_relational_greater_equal_policy {
};//xst_relational_greater_equal_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L>=R -> A<R_=1,L_=1,id>, where A := xst_relational_greater_equal_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_relational_greater_equal_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>>=</tt> lambda expressions.
 *
 @code
    L>=R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_relational_greater_equal_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of relational greater equal operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L>=R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( >= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) >= rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L>=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L>=R</tt> succeeds if integral result of lambda
    *    expression <tt>L>=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_relational_greater_equal_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L>=M -> A<M_,L_=1,id>, where A := xst_relational_greater_equal_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_relational_greater_equal_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>>=</tt> lambda expressions.
 *
 @code
    L>=M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_relational_greater_equal_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of relational greater equal operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L>=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( >= " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) >= rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L>=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L>=M</tt> succeeds if integral result of lambda
    *    expression <tt>L>=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_relational_greater_equal_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:229
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_equality_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_equality_policy {
};//xst_equality_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L==R -> A<R_=1,L_=1,id>, where A := xst_equality_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_equality_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>==</tt> lambda expressions.
 *
 @code
    L==R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_equality_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of equality operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L==R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( == " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) == rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L==R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L==R</tt> succeeds if integral result of lambda
    *    expression <tt>L==R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_equality_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L==M -> A<M_,L_=1,id>, where A := xst_equality_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_equality_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>==</tt> lambda expressions.
 *
 @code
    L==M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_equality_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of equality operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L==M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( == " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) == rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L==M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L==M</tt> succeeds if integral result of lambda
    *    expression <tt>L==M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_equality_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:248
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_inequality_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_inequality_policy {
};//xst_inequality_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L!=R -> A<R_=1,L_=1,id>, where A := xst_inequality_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_inequality_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>!=</tt> lambda expressions.
 *
 @code
    L!=R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_inequality_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of inequality operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L!=R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( != " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) != rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L!=R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L!=R</tt> succeeds if integral result of lambda
    *    expression <tt>L!=R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_inequality_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L!=M -> A<M_,L_=1,id>, where A := xst_inequality_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_inequality_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>!=</tt> lambda expressions.
 *
 @code
    L!=M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_inequality_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of inequality operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L!=M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( != " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) != rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L!=M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L!=M</tt> succeeds if integral result of lambda
    *    expression <tt>L!=M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_inequality_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:267
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_bitwise_and_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_bitwise_and_policy {
};//xst_bitwise_and_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L&R -> A<R_=1,L_=1,id>, where A := xst_bitwise_and_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_and_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>&</tt> lambda expressions.
 *
 @code
    L&R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_bitwise_and_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of bitwise and operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L&R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( & " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) & rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L&R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L&R</tt> succeeds if integral result of lambda
    *    expression <tt>L&R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_and_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L&M -> A<M_,L_=1,id>, where A := xst_bitwise_and_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_and_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>&</tt> lambda expressions.
 *
 @code
    L&M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_bitwise_and_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of bitwise and operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L&M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( & " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) & rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L&M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L&M</tt> succeeds if integral result of lambda
    *    expression <tt>L&M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_and_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:286
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_bitwise_ior_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_bitwise_ior_policy {
};//xst_bitwise_ior_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L|R -> A<R_=1,L_=1,id>, where A := xst_bitwise_ior_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_ior_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>|</tt> lambda expressions.
 *
 @code
    L|R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_bitwise_ior_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of bitwise inclusive or operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L|R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( | " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) | rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L|R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L|R</tt> succeeds if integral result of lambda
    *    expression <tt>L|R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_ior_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L|M -> A<M_,L_=1,id>, where A := xst_bitwise_ior_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_bitwise_ior_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>|</tt> lambda expressions.
 *
 @code
    L|M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_bitwise_ior_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of bitwise inclusive or operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L|M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( | " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) | rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L|M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L|M</tt> succeeds if integral result of lambda
    *    expression <tt>L|M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_bitwise_ior_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:305
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_logical_and_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_logical_and_policy {
};//xst_logical_and_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L&&R -> A<R_=1,L_=1,id>, where A := xst_logical_and_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_logical_and_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>&&</tt> lambda expressions.
 *
 @code
    L&&R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_logical_and_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of logical and operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L&&R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( && " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) && rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L&&R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L&&R</tt> succeeds if integral result of lambda
    *    expression <tt>L&&R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_logical_and_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L&&M -> A<M_,L_=1,id>, where A := xst_logical_and_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_logical_and_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>&&</tt> lambda expressions.
 *
 @code
    L&&M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_logical_and_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of logical and operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L&&M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( && " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) && rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L&&M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L&&M</tt> succeeds if integral result of lambda
    *    expression <tt>L&&M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_logical_and_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:324
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_logical_or_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_logical_or_policy {
};//xst_logical_or_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L||R -> A<R_=1,L_=1,id>, where A := xst_logical_or_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_logical_or_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>||</tt> lambda expressions.
 *
 @code
    L||R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_logical_or_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of logical or operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L||R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( || " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) || rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L||R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L||R</tt> succeeds if integral result of lambda
    *    expression <tt>L||R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_logical_or_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L||M -> A<M_,L_=1,id>, where A := xst_logical_or_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_logical_or_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>||</tt> lambda expressions.
 *
 @code
    L||M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_logical_or_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_bool;

    /**Implementation of logical or operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L||M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_bool
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( || " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) || rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L||M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L||M</tt> succeeds if integral result of lambda
    *    expression <tt>L||M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_logical_or_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:343
// generated by bin/gmu/gmu_lambda/binary_adaptors.h:5
// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:1
/**Primary template for cttt_impl::xst_exclusive_or_policy is not used and is empty.*/
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT >
struct xst_exclusive_or_policy {
};//xst_exclusive_or_policy

// generated by bin\gmu\gmu_lambda\operators/gp_binary_adaptor.h:7

// L^R -> A<R_=1,L_=1,id>, where A := xst_exclusive_or_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_exclusive_or_policy< 1, 1, PrimitiveIdT >
 * @brief Partial specialization policy for binary <tt>^</tt> lambda expressions.
 *
 @code
    L^R
 @endcode
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int PrimitiveIdT >
struct xst_exclusive_or_policy< /*RhsCapacityT*/1, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of exclusive or operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L^R</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( ^ " );
        CTTL_TRACE_DEPOSIT_LINE( "A<R_=1,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) ^ rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L^R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L^R</tt> succeeds if integral result of lambda
    *    expression <tt>L^R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_exclusive_or_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:8
// generated by bin\gmu\gmu_lambda\operators/gp_binary_multi_adaptor.h:1

// L^M -> A<M_,L_=1,id>, where A := xst_exclusive_or_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT >

/**@struct xst_exclusive_or_policy< RhsCapacityT, 1, PrimitiveIdT >
 * @brief General purpose policy for binary <tt>^</tt> lambda expressions.
 *
 @code
    L^M
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 */
template< int RhsCapacityT, int PrimitiveIdT >
struct xst_exclusive_or_policy< RhsCapacityT, /*LhsCapacityT*/1, PrimitiveIdT > {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_arithmetic;

    /**Implementation of exclusive or operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of lambda expression <tt>L^M</tt>.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static
    typename xst_binary_operator_traits<
        typename LambdaRhsT::value_T,
        typename LambdaLhsT::value_T,
        operator_id_arithmetic
    >::value_type
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        CTTL_TRACE_DEPOSIT_TEXT( "( ^ " );
        CTTL_TRACE_DEPOSIT_LINE( "A<M_,L_=1,id>" );
        CTTL_TRACE_DEPOSIT_DELAYED_CHAR( ')' );
        return lhs_lambda_.top( const_scalar( 0 ) ) ^ rhs_lambda_;
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>L^M</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L^M</tt> succeeds if integral result of lambda
    *    expression <tt>L^M</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_exclusive_or_policy

// generated by bin/gmu/gmu_lambda/binary_adaptors.h:362
// generated by bin\gmu\gmu_lambda\operators/comma/custom_comma_adaptor.h:1

// L,R -> A<R_,L_,id>, where A := xst_comma_policy< RhsCapacityT, LhsCapacityT, PrimitiveIdT >

/**@struct xst_comma_policy
 * @brief General purpose policy for binary <tt>,</tt> lambda expressions.
 *
 @code
    L,R
 @endcode
 *
 * @tparam RhsCapacityT
 *        specifies capacity of the right-hand-side lambda operand.
 *
 * @tparam LhsCapacityT
 *        specifies capacity of the left-hand-side lambda operand.
 *
 * @tparam PrimitiveIdT
 *        Template parameter to identify left-hand-side lambda primitive.
 *
 * @remarks
 * - The comma operator has left-to-right associativity.
 * - Two expressions separated by a comma are evaluated left to right.
 * - The left operand is always evaluated, and all side effects
 *   are completed before the right operand is evaluated.
 * - The type and value of the expression are the type and value of R.
 * - The result of evaluating L is discarded.
 * - The result is an rvalue obtained as a copy of the result of R.
 *
 */
template< int RhsCapacityT, int LhsCapacityT, int PrimitiveIdT > 
struct xst_comma_policy {

    /**Constant describing internal operator id.*/
    static const int operator_id_ = operator_id_comma;

    /**Implementation of comma operator for
    *  CTTL lambda expression.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @return
    *        computes and returns evaluation result
    *        of <tt>R</tt>. Result of evaluating <tt>L</tt> is discarded.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT >
    static typename LambdaRhsT::value_T
    top(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_
        )
    {
        lhs_lambda_.top( const_scalar( 0 ) );
        CTTL_TRACE_DEPOSIT_TEXT( ',' );
        CTTL_UNILOG_FLUSH;
        CTTL_TRACE_DEPOSIT_JUSTIFY();
        return rhs_lambda_.top( const_scalar( 0 ) );
    }

    /**Implements <a href="http://cttl.sourceforge.net/">CTTL</a>
    *  grammar <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1100_grammar.html">evaluation algorithm</a>.
    *
    * @tparam LambdaLhsT
    *        specifies type of
    *        left-hand-side lambda operand.
    *
    * @tparam LambdaRhsT
    *        specifies type of
    *        right-hand-side lambda operand.
    *
    * @tparam SubstrT
    *        specifies type of
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @param lhs_lambda_
    *        left-hand-side lambda operand.
    *
    * @param rhs_lambda_
    *        right-hand-side lambda operand.
    *
    * @param edge_
    *        reference to the
    *        parseable <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page0300_edge.html">substring</a>.
    *
    * @pre
    *        Result of expression <tt>R</tt> is integral type.
    *
    * @return
    *    <a href="http://cttl.sourceforge.net/cttl300docs/manual/cttl/page1300_interface.html">evaluation result</a>.
    *    Grammar expression <tt>L,R</tt> succeeds if integral result of lambda
    *    expression <tt>R</tt> is not zero, otherwise it fails.
    *
    */
    template< typename LambdaLhsT, typename LambdaRhsT, typename SubstrT >
    static size_t
    match(
        LambdaLhsT const& lhs_lambda_,
        LambdaRhsT const& rhs_lambda_,
        SubstrT const& edge_
        )
    {
        // switch
        if ( top( lhs_lambda_, rhs_lambda_ ) )
            return edge_.first.offset();

        return SubstrT::string_T::npos;
    }

}; // xst_comma_policy


}   // namespace cttl_impl


#endif //_XST_OPERATOR_ADAPTORS_H_INCLUDED_
